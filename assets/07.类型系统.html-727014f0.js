import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as p,a as n,b as s,f as a,d as t}from"./app-12e502b6.js";const l={},d=n("h1",{id:"类型系统",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#类型系统","aria-hidden":"true"},"#"),s(" 类型系统")],-1),u={href:"https://mp.weixin.qq.com/s/qQsLP5o7U8AG_phzGzbjJg",target:"_blank",rel:"noopener noreferrer"},r={href:"https://halfrost.com/go_interface/",target:"_blank",rel:"noopener noreferrer"},m=t(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>在编译期间，编译器知道每种类型定义得方法，方法本质是函数，所以在方法得调用上，接收者作为第一个参数传入。这也是为什么 <code>t.F1()==F1(t)</code> 等价得原因。</p><p>到了执行阶段，为了支持<strong>反射，接口动态派发，类型断言</strong>这些语言特性或机制，编译器会给每种类型生成对应得<strong>类型描述信息</strong>写入执行文件，这些类型描述信息就是<strong>类型元数据</strong>。</p><p>以下都是 <code>Go</code> 语言的内置类型：</p><ul><li>内置字符串类型：<code>string</code>。</li><li>内置布尔类型：<code>bool</code>.</li><li>内置数值类型： <ul><li><code>int8</code>、<code>uint8</code>（<code>byte</code>）、<code>int16</code>、<code>uint16</code>、<code>int32</code>（<code>rune</code>）、<code>uint32</code>、<code>int64</code>、<code>uint64</code>、<code>int</code>、<code>uint</code>、<code>uintptr</code>。</li><li><code>float32</code>、<code>float64</code>。</li><li><code>complex64</code>、<code>complex128</code>。</li></ul></li></ul><p>注：<code>byte</code>是<code>uint8</code>的一个内置别名，<code>rune</code>是<code>int32</code>的一个内置别名。</p><p>我们也可以自己定义类型。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">//可以给自定义类型定义方法。</span>
<span class="token keyword">type</span> T1 <span class="token builtin">int</span>
<span class="token comment">//可以给自定义类型定义方法。</span>
<span class="token keyword">type</span> T2 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token comment">//接口类型是无效的方法接收者</span>
<span class="token keyword">type</span> T3 <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据类型很多，不管是内置类型还是自定义类型，他的类型元数据是全局唯一的，这些类型元数据共同构成了 <code>Go</code> 语言的<strong>类型系统</strong>。</p><p>那么开始正题吧！</p><h2 id="内置数据类型元数据" tabindex="-1"><a class="header-anchor" href="#内置数据类型元数据" aria-hidden="true">#</a> 内置数据类型元数据</h2><p>每个类型元数据基础信息都放到了 <code>runtime._type</code> 结构体中，作为每个类型元数据的 <code>Header</code>。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> _type <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    size       <span class="token builtin">uintptr</span> <span class="token comment">//大小</span>
    ptrdata    <span class="token builtin">uintptr</span> <span class="token comment">//含有所有指针类型前缀大小</span>
    hash       <span class="token builtin">uint32</span>  <span class="token comment">//类型</span>
    tflag      tflag <span class="token comment">//类型的特征标记</span>
    align      <span class="token builtin">uint8</span> <span class="token comment">//作为整体变量存放时的对齐字节数</span>
    fieldalign <span class="token builtin">uint8</span> <span class="token comment">//当前结构字段的对齐字节数</span>
    kind       <span class="token builtin">uint8</span> <span class="token comment">//基础类型枚举值和反射中的 Kind 一致，kind 决定了如何解析该类型</span>
    alg        <span class="token operator">*</span>typeAlg <span class="token comment">//指向一个函数指针表，该表有两个函数，一个是计算类型 Hash 函数。另一个是比较两个类型是否相同的 equal 函数</span>
    gcdata     <span class="token operator">*</span><span class="token builtin">byte</span> <span class="token comment">//GC 相关</span>
    str        nameOff  <span class="token comment">//类型名称字符串在二进制文件段中的偏移量</span>
    ptrToThis  typeOff <span class="token comment">//类型元信息指针在二进制文件段中的偏移量</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_type</code> 存储基本信息，还有额外需要描述的信息也需要存储。例如 <code>slice</code> 的类型元数据在 <code>_type</code> 结构体后面记录了一个 <code>*_type</code>，指向其存储元素的类型元数据。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> slicetype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    typ   _type
    elem  <span class="token operator">*</span>_type <span class="token comment">//指向存储元素的类型元数据，如果存储string类型，那么这个指针指向 string 类型的元数据</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指针类型也是如此。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> ptrtype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    typ   _type
    elem  <span class="token operator">*</span>_type <span class="token comment">//指向 指针类型指向的类型元数据 例如 *int 那么elem指向 int 类型的元数据</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有些内置类型就没有这么简单。例如 <code>map</code>，<code>struct</code>。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> maptype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	typ    _type
	key    <span class="token operator">*</span>_type
	elem   <span class="token operator">*</span>_type
	bucket <span class="token operator">*</span>_type <span class="token comment">// internal type representing a hash bucket</span>
	<span class="token comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span>
	hasher     <span class="token keyword">func</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span>
	keysize    <span class="token builtin">uint8</span>  <span class="token comment">// size of key slot</span>
	elemsize   <span class="token builtin">uint8</span>  <span class="token comment">// size of elem slot</span>
	bucketsize <span class="token builtin">uint16</span> <span class="token comment">// size of bucket</span>
	flags      <span class="token builtin">uint32</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> structtype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	typ     _type
	pkgPath name
	fields  <span class="token punctuation">[</span><span class="token punctuation">]</span>structfield
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,19),k={href:"https://go.dev/src/runtime/type.go",target:"_blank",rel:"noopener noreferrer"},v=t(`<h2 id="自定义类型元数据" tabindex="-1"><a class="header-anchor" href="#自定义类型元数据" aria-hidden="true">#</a> 自定义类型元数据</h2><p>如果是自定义类型，那么类型元数据的结构体后面还会有一个 <code>uncommontype</code> 结构体。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> uncommontype <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    pkgpath nameOff <span class="token comment">//记录类型所在的包路径；</span>
    mcount  <span class="token builtin">uint16</span>  <span class="token comment">// 记录了该类型关联到多少个方法；</span>
    <span class="token boolean">_</span>       <span class="token builtin">uint16</span> <span class="token comment">// unused</span>
    moff    <span class="token builtin">uint32</span>  <span class="token comment">//记录的是这些方法的元数据组成的数组，相对于这个uncommontype结构体偏移了多少字节。</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法元数据</span>
<span class="token keyword">type</span> method <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name nameOff <span class="token comment">// 方法名称偏移量 </span>
    mtyp typeOff <span class="token comment">//方法的类型元数据</span>
    ifn  textOff <span class="token comment">//fn used in interface call (one-word receiver)</span>
    tfn  textOff <span class="token comment">//fn used for normal method call</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举个例子🌰：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> myslice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment">//定义了一个新的类型 myslice</span>
<span class="token comment">//定义的两个方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ms myslice<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ms myslice<span class="token punctuation">)</span> <span class="token function">Cap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>myslice</code> 类型元数据由以下构成：</p><ul><li><code>slicetype</code> 类型描述信息</li><li><code>uncommontype</code> 结构体</li></ul><p>注：我们可以通过 <code>uncommontype</code> 结构体找到 <code>myslice</code> 的方法元数据列表。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6zYKaJegOORJTgR9YoDe543OpVCTUInWcbfDosK4qObJFAPjMWGX5H1icdYE7gHUq2S2KbbpDJBKA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="alias-别名" tabindex="-1"><a class="header-anchor" href="#alias-别名" aria-hidden="true">#</a> alias 别名</h2><p>在内置数据里面，<code>byte</code>是<code>uint8</code>的一个内置别名，<code>rune</code>是<code>int32</code>的一个内置别名。</p><p>以下有两种方法，他们有什么不同呢？</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> MyType1 <span class="token operator">=</span> <span class="token builtin">int32</span>
<span class="token keyword">type</span> MyType2 <span class="token builtin">int32</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一种方式叫做类型 <code>int32</code> 取别名。实际上 <code>MyType1</code> 和 <code>int32</code> 会关联到同一个类型元数据，属于同一种类型。</li></ul><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6zYKaJegOORJTgR9YoDe54FfpzsjyfEhRNOM8K1wfKSXRsDrLUrWfeU8SyNDx8pw2b0Jb3AOZG7A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ul><li>第二种方式属于创建新类型，拥有自己的类型元数据，<code>MyType2</code> 和 <code>int32</code> 是两个不同的类型，对应元数据也会不同。</li></ul><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6zYKaJegOORJTgR9YoDe54rmcOeCBMj9LjkDERA1W4Q1dQH1ibqUbvonqZZUI1eUhDZGQLwAlfRVg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure>`,17);function b(g,y){const e=c("ExternalLinkIcon");return o(),p("div",null,[d,n("blockquote",null,[n("p",null,[s("推荐阅读："),n("a",u,[s("【Golang】类型系统"),a(e)])]),n("p",null,[n("a",r,[s("深入研究 Go interface 底层实现"),a(e)])])]),m,n("p",null,[s("但是基本结构都是如此。可以来 "),n("a",k,[s("type.go"),a(e)]),s(" 来看看内置类型的元数据")]),v])}const _=i(l,[["render",b],["__file","07.类型系统.html.vue"]]);export{_ as default};
