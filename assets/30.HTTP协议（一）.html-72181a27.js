import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as n,c as l,a as e,b as i,f as t,d}from"./app-12e502b6.js";const r={},p=d('<h1 id="http协议-part1" tabindex="-1"><a class="header-anchor" href="#http协议-part1" aria-hidden="true">#</a> HTTP协议 Part1</h1><p>为了方便，去更好的观察到每个包得真实内容，最好的方式就是搭建一个小型 <code>HTTP</code> 环境。</p><h2 id="搭建-http-实验环境" tabindex="-1"><a class="header-anchor" href="#搭建-http-实验环境" aria-hidden="true">#</a> 搭建 HTTP 实验环境</h2><p>实验环境用到得应用软件：</p><ul><li>Wireshark+NPcap</li><li>Chrome/Firefox</li><li>Telnet</li><li>OpenResty</li></ul>',5),s={href:"https://github.com/chronolaw/http_study",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"构建过程如下：",-1),h={href:"https://github.com/chronolaw/http_study",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"Release",-1),f=e("li",null,[i("安装 "),e("code",null,"Wireshark+NPcap"),i(" 与 "),e("code",null,"Chrome/Firefox"),i("，软件，安装过程比较简单，就是找官网下载相关的版本，选择最新的就可，然后一路下一步就可以安装成功了，"),e("strong",null,[i("注：(先安装 "),e("code",null,"NPcap"),i(" 再安装"),e("code",null,"Wireshark"),i("。安装顺序出错需重新安装)")])],-1),m=e("li",null,"Windows 10自带Telnet，不需要安装，但默认是不启用的，需要你稍微设置一下。打开Windows的设置窗口，搜索“Telnet”，就会找到“启用或关闭Windows功能”，在这个窗口里找到“Telnet客户端”，打上对钩就可以了，可以参考截图。",-1),T=e("figure",null,[e("img",{src:"https://static001.geekbang.org/resource/image/1a/47/1af035861c4fd33cb42005eaa1f5f247.png",alt:"img",tabindex:"0",loading:"lazy"}),e("figcaption",null,"img")],-1),b={start:"4"},_=e("code",null,"OpenResty",-1),y={href:"http://openresty.org/",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"http_study",-1),x=e("figure",null,[e("img",{src:"https://cdn.jsdelivr.net/gh/baici1/img-typora/20220104222534.png",alt:"image-20220104222534119",tabindex:"0",loading:"lazy"}),e("figcaption",null,"image-20220104222534119")],-1),v=d(`<li><p>了能够让浏览器能够使用DNS域名访问我们的实验环境，还要改一下本机的hosts文件，位置在<code>C:\\WINDOWS\\system32\\drivers\\etc</code>，在里面添加三行本机IP地址到测试域名的映射</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>127.0.0.1       www.chrono.com
127.0.0.1       www.metroid.net
127.0.0.1       origin.io
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1),H=d('<p>到这里，安装工作基本上就完成了。下面开始测试，环境是否能正常使用。</p><p>首先，我们要启动 <code>Web</code> 服务器，也就是 <code>OpenResty</code>。在<code> http_study</code> 的 “<code>www</code>” 目录下有四个批处理文件，分别是：</p><ul><li>start：启动OpenResty服务器；</li><li>stop：停止OpenResty服务器；</li><li>reload：重启OpenResty服务器；</li><li>list：列出已经启动的OpenResty服务器进程。</li></ul><p>使用鼠标双击“start”批处理文件，就会启动OpenResty服务器在后台运行，这个过程可能会有Windows防火墙的警告，选择“允许”即可。</p><p>运行后，鼠标双击“list”可以查看OpenResty是否已经正常启动，应该会有两个nginx.exe的后台进程，大概是下图的样子。</p><figure><img src="https://static001.geekbang.org/resource/image/db/1d/dba34b8a38e98bef92289315db29ee1d.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>接下来运行 <code>Wireshark</code>，开始抓包。进行以下配置：</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220104223339.png" alt="image-20220104223339422" tabindex="0" loading="lazy"><figcaption>image-20220104223339422</figcaption></figure><p>鼠标双击开始界面里的“ <code>loopback Adapter</code>”即可开始抓取本机上的网络数据。</p><p>然后我们打开Chrome，在地址栏输入“<code>http://localhost</code>”，访问刚才启动的OpenResty服务器，就会看到一个简单的欢迎界面，如下图所示。</p><figure><img src="https://static001.geekbang.org/resource/image/d7/88/d7f12d4d480d7100cd9804d2b16b8a88.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这时再回头去看Wireshark，应该会显示已经抓到了一些数据，就可以用鼠标点击工具栏里的“停止捕获”按钮告诉Wireshark“到此为止”，不再继续抓包。</p><figure><img src="https://static001.geekbang.org/resource/image/f7/79/f7d05a3939d81742f18d2da7a1883179.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>到现在实验环境已经搭建成功了，后续会利用这个环境进行分析每个包的内容。</p><h2 id="键入网址再按下回车会发生什么" tabindex="-1"><a class="header-anchor" href="#键入网址再按下回车会发生什么" aria-hidden="true">#</a> 键入网址再按下回车会发生什么？</h2><p>这是一个常见的面试题目！</p>',16),k={href:"https://www.guide.yangdiy.cn/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88%E7%AF%87",target:"_blank",rel:"noopener noreferrer"},C=e("code",null,"HTTP",-1),E=d(`<p>我们启动一下这个实验环境，在 <code>Chrome</code> 浏览器里面输入 <code>http://127.0.0.1/</code> ，再按下回车键，等待页面的出来，就会在 <code>Wireshark</code> 看到如下画面：</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220105215520.png" alt="image-20220105215520494" tabindex="0" loading="lazy"><figcaption>image-20220105215520494</figcaption></figure><p>注：如果你发现的捕获的包数量少于 11 个包，同时返回的状态码是 304，说明此网站已经缓存了，你可再找一个浏览器进行实验。</p><h3 id="抓包分析" tabindex="-1"><a class="header-anchor" href="#抓包分析" aria-hidden="true">#</a> 抓包分析</h3><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220105220846.png" alt="image-20220105220846593" tabindex="0" loading="lazy"><figcaption>image-20220105220846593</figcaption></figure><p>最开始三个包，是在建立浏览器与服务器的 <code>TCP</code> 连接，可以很明显的看出 <code>Web</code> 服务器的端口是 80，而客户端（浏览器）的端口是 13014，和我们预想的一样三次握手一样。</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220112153831.png" alt="image-20220112153830990" tabindex="0" loading="lazy"><figcaption>image-20220112153830990</figcaption></figure><p>当建立了 <code>TCP</code> 连接后，HTTP 协议就开始工作了，浏览器会发送一个通过TCP发送了一个<code>GET / HTTP/1.1</code>请求报文，也就是 <code>Wireshark</code> 里的第四个包。</p><p>接下来，<code>Web</code> 服务器就会回复第五个包，也就是确认包（<code>ACK</code>）。确认刚才报文已收到。</p><p>Web 服务器收到报文后，会在内部解析这个请求，看看浏览器发送这个请求想要干什么。</p><p>明确要求获取根目录下的默认文件，就从磁盘上把那个文件全读出来，再拼成符合 <code>HTTP</code> 格式的报文，发回去吧。这就是 <code>Wireshark</code> 里的第六个包 “HTTP/1.1 200 OK”，底层走的还是 <code>TCP</code> 协议。</p><p>当接收到服务器发送的报文（第六个包），浏览器就会给服务器回复一个确认包（<code>ACK</code>），确认收到了，这就是第七个包。</p><p>浏览器收到了响应数据后，就会调用引擎处理，渲染等过程，将页面展现出来。</p><p>到这里，你是不是觉得要结束了？❓❓❓</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220112154307.png" alt="image-20220112154307779" tabindex="0" loading="lazy"><figcaption>image-20220112154307779</figcaption></figure><p>其实并没有， 接下来浏览器还会自动去请求网站图标，但是我们这里没有这个文件，所以会返回 404。</p><p>到此，你输入网址再按下回车的过程 HTTP 部分已经结束了。</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220112155234.png" alt="image-20220112155233973" tabindex="0" loading="lazy"><figcaption>image-20220112155233973</figcaption></figure><p>工作完成后，好像并没有直接进入到 <code>TCP</code> 挥手，反而有上图的情况，前两个包可能是告知对方，工作完成了，进入到长连接状态，后面一大段都是双方处于保持连接状态里面。</p><p><code>http</code> 协议是采用请求-问答的方式，当处于普通模式，双方建立连接，完成工作，就会断开连接，当处于 <code>Keep-alive</code> 模式时，双方建立连接，即使工作完成了，此连接依旧有效状态。<code>keep-alive</code> 模式避免了重新建立连接。</p><p><code>http1.0</code> 中默认是关闭的，需要在http头加入<code>”Connection: Keep-Alive”</code>，才能启用 <code>Keep-Alive</code>；</p><p><code>http 1.1</code> 中默认启用 <code>Keep-Alive</code>，目前大部分浏览器都是用 <code>http1.1</code>协议。</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220112155819.png" alt="image-20220112155819902" tabindex="0" loading="lazy"><figcaption>image-20220112155819902</figcaption></figure><p>当我们决定关闭服务器时候，双方就会开始 <code>TCP</code> 挥手。</p><p>总结一下浏览器 <code>HTTP</code> 请求过程：</p><ol><li>浏览器从地址栏的输入中获得服务器的 <code>IP</code> 地址和端口号；</li><li>浏览器用 <code>TCP</code> 的三次握手与服务器建立连接；</li><li>浏览器向服务器发送拼好的报文；</li><li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li><li>浏览器解析报文，渲染输出页面。</li><li>关闭浏览器或者服务器就会 <code>TCP</code> 挥手断开连接。</li></ol><h3 id="http-报文解析" tabindex="-1"><a class="header-anchor" href="#http-报文解析" aria-hidden="true">#</a> HTTP 报文解析</h3><p><code>HTTP</code> 协议核心是报文的内容，不同报文格式，会实现更加灵活丰富的功能。</p><h4 id="报文结构" tabindex="-1"><a class="header-anchor" href="#报文结构" aria-hidden="true">#</a> 报文结构</h4><p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ol><li>起始行（start line）：描述请求或响应的基本信息；</li><li>头部字段集合（header）：使用key-value形式更详细地说明报文；</li><li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据</li></ol><p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”。</p><p><code>HTTP</code> 协议规定报文必须有 <code>header</code>，但可以没有 <code>body</code>，而且在 <code>header</code> 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p><figure><img src="https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们来看看抓取到的 <code>HTTP</code> 协议。</p><figure><img src="https://cdn.jsdelivr.net/gh/baici1/img-typora/20220112161630.png" alt="image-20220112161630664" tabindex="0" loading="lazy"><figcaption>image-20220112161630664</figcaption></figure><p>请求报文里面没有 <code>body</code>。一般 GET 请求都是如此只有 <code>header</code> 没有 <code>body</code>。虽然 <code>HTTP</code> 协议对 <code>header</code> 的大小没有做限制，但各个 <code>Web</code> 服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率，同时浏览器也会做一定限制。</p><h4 id="起始行" tabindex="-1"><a class="header-anchor" href="#起始行" aria-hidden="true">#</a> 起始行</h4><p>请求行，简要地描述了，客户端将会如何操作服务端地资源，相当于我要借东西，提前跟别人打个招呼。</p><p>请求行由三部分构成：</p><ol><li>请求方法：是一个动词，如 <code>GET/POST</code>，表示对资源的操作；</li><li>请求目标：通常是一个 <code>URI</code>，标记了请求方法要操作的资源；</li><li>版本号：表示报文使用的 <code>HTTP</code> 协议版本。</li></ol><p>很清楚看到 <code>HTTP</code> 版本是 1.1 。</p><p>这三个部分通常使用空格（space）来分隔，最后要用CRLF换行表示结束。</p><figure><img src="https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>🌰：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET / HTTP/1.1\\r\\n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在此请求行中，<code>GET</code>是请求方法，<code>/</code> 是请求目标，<code>HTTP/1.1</code> 是版本号。</p><p>咦~~，服务器向发送地报文格式好像和这个对不上啊。</p><p>对于响应报文里面，这里并不叫请求行，而是状态行，反应了服务器对此次请求的状态表现。</p><p>状态行要简单一些，同样也是由三部分构成：</p><ol><li>版本号：表示报文使用的 <code>HTTP</code> 协议版本；</li><li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li><li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li></ol><figure><img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>🌰：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 200 OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此状态行中，协议版本号是 1.1，状态码是 200，补充文字：OK。</p><h4 id="头部字段" tabindex="-1"><a class="header-anchor" href="#头部字段" aria-hidden="true">#</a> 头部字段</h4><p>在头部字段里，请求报文与响应报文结构基本是一致的。</p><p>头部字段是 <code>key-value</code> 的形式，<code>key</code> 和<code> value</code>之间用“:”分隔，最后用CRLF换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 <code>key</code> 就是“Host”，<code>value</code> 就是“127.0.0.1”。</p><p><code>HTTP</code> 头字段非常灵活，不仅可以使用标准里的 <code>Host</code>、<code>Connection</code> 等已有头，也可以任意添加自定义头，这就给 <code>HTTP</code> 协议带来了无限的扩展可能。</p><p>不过使用头字段需要注意下面几点：</p><ol><li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li><li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li><li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li><li>字段的顺序是没有意义的，可以任意排列不影响语义；</li><li>字段原则上不能重复，除非这个字段本身的语义允许，例如Set-Cookie。</li></ol><p>我们来说说常用的头字段：</p><ul><li><strong>Host <strong>字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 <code>HTTP/1.1</code> 规范里要求</strong>必须出现</strong>的字段，也就是说，如果请求头里没有 <code>Host</code>，那这就是一个错误的报文。</li><li><strong>User-Agent</strong> 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 <code>HTTP</code> 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</li><li><strong>Date</strong> 字段是一个通用字段，但通常出现在响应头里，表示 <code>HTTP</code> 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略</li><li>**Server **字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 <code>Web</code> 服务的软件名称和版本号</li><li><strong>Content-Length</strong>，它表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。</li></ul><h4 id="请求方式" tabindex="-1"><a class="header-anchor" href="#请求方式" aria-hidden="true">#</a> 请求方式</h4><ol><li>GET：获取资源，可以理解为读取或者下载数据；</li><li>HEAD：获取资源的元信息；</li><li>POST：向资源提交数据，相当于写入或上传数据；</li><li>PUT：类似POST；</li><li>DELETE：删除资源；</li><li>CONNECT：建立特殊的连接隧道；</li><li>OPTIONS：列出可对资源实行的方法；</li><li>TRACE：追踪请求-响应的传输路径。</li></ol>`,65);function W(O,w){const o=c("ExternalLinkIcon");return n(),l("div",null,[p,e("p",null,[i("同时需要用到这样一个环境"),e("a",s,[i("http_study"),t(o)]),i("。")]),g,e("ol",null,[e("li",null,[i("首先从 "),e("a",h,[i("http_study"),t(o)]),i(" 下载相关得源码，在 "),u,i(" 页面里面，将其压缩。")]),f,m]),T,e("ol",b,[e("li",null,[e("p",null,[i("安装 "),_,i("，去它的"),e("a",y,[i("官网"),t(o)]),i("，点击左边栏的“Download”，进入下载页面，下载适合你系统的版本，将压缩包解压到刚才的 "),P,i(" 文件里面。结果如下：")]),x]),v]),H,e("p",null,[i("其实在"),e("a",k,[i("网络综合篇"),t(o)]),i("已经进行一定的分析，而今天我们需要分析呢，主要分析 "),C,i(" 协议在这个过程中到底干了什么，不能光理论，得实操一下，亲眼见见才行。")]),E])}const R=a(r,[["render",W],["__file","30.HTTP协议（一）.html.vue"]]);export{R as default};
