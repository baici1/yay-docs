import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as i,c as l,a as n,b as s,f as e,d as o}from"./app-12e502b6.js";const u={},d=n("h1",{id:"闭包",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#闭包","aria-hidden":"true"},"#"),s(" 闭包")],-1),r={href:"https://mp.weixin.qq.com/s/iFYkcLbNK5pOA37N7ToJ5Q",target:"_blank",rel:"noopener noreferrer"},k=o(`<h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><p>函数，<code>Go</code> 语言中属于头等对象，你可以作为参数进行传递，也可以作为函数返回值，绑定到变量，甚至可以作为一种类型。<code>Go</code> 语言称这样的参数、返回值和变量为<strong>Function Value</strong>。</p><p><code>Function Value</code> 本质上是一个指针，却不直接指向函数指令入口，而是指向 <code>runtime.funcval</code> 结构体。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> funcval <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//uintptr 是一个整数类型，它大到足以容纳任何指针的位模式。</span>
    fn <span class="token builtin">uintptr</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从结构体的字段定义来看，似乎是一个地址，这个地址应该就是函数入口了。</p><p>通过以下方式找到函数入口：</p>`,6),m=o(`<p>举个例子🌰：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i<span class="token operator">++</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>  
<span class="token keyword">func</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    f1 <span class="token operator">:=</span> A
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    f2 <span class="token operator">:=</span> A
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个函数中，多个变量都用到一个函数 A，那么编译器在编译阶段就会做出一定的优化，让他们都共用一个 <code>funcval</code> 结构体。在执行阶段，就会去使用它。</p><blockquote><p>❓：明明可以直接调用函数入口，为什么要通过 <code>funcval</code> 结构体包装函数入口地址，然后使用一个二级指针来调用呢？</p></blockquote><h2 id="闭包-1" tabindex="-1"><a class="header-anchor" href="#闭包-1" aria-hidden="true">#</a> 闭包</h2><h3 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h3><blockquote><p>维基百科</p><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括<strong>自由变量（在函数外部定义但在函数内被引用）</strong>，有些函数也可能没有自由变量。闭包跟函数最大的不同在于，<strong>当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。</strong></p></blockquote><p>举个例子🌰：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    f1 <span class="token operator">:=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    f2 <span class="token operator">:=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>create</code> 函数的返回值是一个函数，这个函数引用了 <code>create</code> 函数的局部变量 <code>c</code>。满足拥有自由变量。</li><li><code>f1 := create()</code> 结束后，依然可以通过 <code>f1()</code> 可以正常执行函数，同时去使用捕获到的自由变量 <code>c</code>。</li></ul><p>根据上面两个定义结合维基百科的解释，create 的返回值函数满足闭包的定义，这个自由变量 <code>c</code> 通常被称之为 <strong>捕获变量</strong>。</p><p>虽然create函数的返回值函数形成闭包，但是Go语言里并没有把闭包从 <code>Function Value</code> 中特别区分出来。<strong>在Go语言中闭包只是拥有一个或多个捕获变量的Function Value而已</strong>。这些捕获变量就是它的捕获列表，就放在对应的<code>funcval</code> 结构体的后面。</p><img title="" src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L54GNVaa321QQp7AWgFWqoHQl4ViapborPzvzVv6HAeOvjLnOpwO71HC9PHOB02uytKrBuKy7f9H3A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" data-align="inline"><p>每个闭包对象都是一个<code>Function Value</code>，但是各自持有自己的捕获列表，这也是称闭包为<strong>有状态的函数</strong>的原因。</p><h3 id="调用捕获变量" tabindex="-1"><a class="header-anchor" href="#调用捕获变量" aria-hidden="true">#</a> 调用捕获变量</h3><ul><li>当 <code>Function Value</code> 调用函数时候，会将二级地址也就是 <code>funcval</code> 结构体地址存入特定寄存器，例如<code>amd64</code> 平台使用的是 <code>DX</code> 寄存器。</li><li>当闭包函数执行时候，就可以通过寄存器存储地址加上偏移量找到自己的捕获变量。</li><li>如果是没有捕获列表的 <code>Function Value</code>，直接忽略这个寄存器即可。通过这样的方式，<code>Go</code> 语言实现了对 <code>Function Value</code> 的统一调用。</li></ul><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L54GNVaa321QQp7AWgFWqoHKOc70kcuA66mh8YJUqibTpUCUab0aeDutPZ8m2XowkslNI2vTpXJLaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="捕获列表" tabindex="-1"><a class="header-anchor" href="#捕获列表" aria-hidden="true">#</a> 捕获列表</h3><p>捕获列表变量时怎么来的？值拷贝？存储地址？这是一问题。</p><p>注意点：<strong>闭包捕获的变量要在闭包函数和外层函数中表现一致。</strong></p><p>如果是值拷贝，就<strong>无法保证闭包捕获的变量要在闭包函数和外层函数中表现一致</strong>，所以编译器对捕获变量的不同情况做出不同的处理。请记住：无论做什么处理，只有一个目的：<strong>闭包捕获的变量要在闭包函数和外层函数中表现一致</strong>。</p><ul><li>捕获变量进行初始化赋值，就没有再次修改了</li><li>捕获变量初始化赋值，还被修改过。 <ul><li>捕获变量是局部变量</li><li>捕获变量是参数</li><li>捕获变量是返回值</li></ul></li></ul><blockquote><p>初始化赋值，不再修改</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    f1 <span class="token operator">:=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    f2 <span class="token operator">:=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>他的捕获变量初始化赋值后，之后再也没有修改了，那么这个捕获变量就直接拷贝值，然后放到 <code>funcval</code> 结构体后面。</p><blockquote><p>捕获局部变量</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>fs <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>    
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fs <span class="token operator">:=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，捕获变量是局部变量 i，经过初始化赋值后，还被修改过。这个局部变量会被改为堆分配。</p><p>流程如下：</p><ul><li>在 <code>create</code> 函数栈帧中，局部变量 <code>i</code> 被闭包捕获，因为后续会更改，所以就会被分配到堆上，在栈上的局部变量空间会存储他在堆上的地址，<code>for</code> 循环还没有开始，<code>i</code> 等于 <code>0</code>。</li><li>第一次 <code>for</code> 循环，就会在堆上创建一个 <code>funcval</code> 结构体，指向闭包函数入口，同时后面是捕获变量 <code>i</code> 的地址。<code>i</code> 自增加一，注：<strong><code>create</code> 函数与闭包函数 共用一个堆。</strong></li><li>第二次 <code>for</code> 循环，操作同上</li><li>返回值空间分别是两次创建的 <code>funcval</code> 结构体的地址 <code>addr1,addr2</code>。</li><li><code>fs</code> 的变量空间分别被返回值进行赋值</li><li>通过多次地址指向，执行 <code>fs</code> 空间对应的函数，此时输出的 <code>i</code> 的值就是分配到堆上捕获变量 <code>i</code> 的值。所以只会输出 <code>2</code>。</li></ul><p>上面的流程的目的只有一个：<strong>闭包捕获的变量要在闭包函数和外层函数中表现一致。</strong></p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L54GNVaa321QQp7AWgFWqoHmQv6MChzBPc105nxia4smqBYTCpibNgmslLibDysicEFUEFGc19ibOklFew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><blockquote><p>捕获参数</p></blockquote><p>如果是参数被捕获，那么调用者依然从栈上传递参数，但是被调用函数会把它拷贝到堆上一份，然后和闭包函数都使用堆上分配的那一个。方式与捕获局部变量一致。</p><blockquote><p>捕获返回值</p></blockquote><p>如果是返回值被捕获，那么处理方式就又有些不同了。返回值空间依然由调用者在栈上分配，但是被调用函数（闭包的外层函数）会在堆上也分配一个，并且与闭包函数都使用堆上这一个。但是，在外层函数返回前要把堆上的返回值拷贝到栈上那一个。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L54GNVaa321QQp7AWgFWqoH06W5mF0Fu767ahbeqA26FXbz12p6xRMUvDLTODLkQ0wl4oaLvCd1bw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>注：闭包对于捕获变量所有的操作，目的只有一个：<strong>闭包捕获的变量要在闭包函数和外层函数中表现一致。</strong></p>`,38);function v(b,f){const p=a("ExternalLinkIcon"),t=a("Mermaid");return i(),l("div",null,[d,n("blockquote",null,[n("p",null,[s("推荐学习："),n("a",r,[s("【Golang】图解Function value"),e(p)])])]),k,e(t,{id:"mermaid-24",code:"eJxLL0osyFDwCeJSAAK30rzkksz8vLDEnNJUXV27otK8kszcVL00oHhZYg5Q5Gn73mdTNzxtXfq0fzEXAINqGHM="}),m])}const w=c(u,[["render",v],["__file","09.闭包.html.vue"]]);export{w as default};
