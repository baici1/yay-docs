import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as a,a as e,b as o,f as d,d as i}from"./app-12e502b6.js";const s={},c=e("h1",{id:"mysql",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mysql","aria-hidden":"true"},"#"),o(" Mysql")],-1),g=e("p",null,"参考以及推荐文章：",-1),h={href:"https://www.codedump.info/post/20200609-btree-1/",target:"_blank",rel:"noopener noreferrer"},p={href:"https://javaguide.cn/database/mysql/mysql-index/#b-%E6%A0%91-b-%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},u=i('<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><h3 id="_1-什么是数据库-数据库管理系统-数据库系统-数据库管理员-简写分别是什么" tabindex="-1"><a class="header-anchor" href="#_1-什么是数据库-数据库管理系统-数据库系统-数据库管理员-简写分别是什么" aria-hidden="true">#</a> 1.什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?简写分别是什么？</h3><p><strong>数据库</strong> : 数据库(<code>DataBase</code> 简称 <code>DB</code>)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</p><p><strong>数据库管理系统</strong> : 数据库管理系统(<code>Database Management System</code> 简称 <code>DBMS</code>)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</p><p><strong>数据库系统</strong> : 数据库系统(<code>Data Base System</code>，简称 <code>DBS</code>)通常由软件、数据库和数据管理员(DBA)组成。</p><p><strong>数据库管理员</strong> : 数据库管理员(<code>Database Administrator</code>, 简称 <code>DBA</code>)负责全面管理和控制数据库系统。</p><h3 id="_2-主键-外键有什么区别-为什么不是很推荐使用外键" tabindex="-1"><a class="header-anchor" href="#_2-主键-外键有什么区别-为什么不是很推荐使用外键" aria-hidden="true">#</a> 2.主键，外键有什么区别?为什么不是很推荐使用外键？</h3><table><thead><tr><th></th><th>主键</th><th>外键</th></tr></thead><tbody><tr><td>定义</td><td>用于唯一标识一个元组，不能有重复，不允许为空。</td><td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值</td></tr><tr><td>作用</td><td>保证数据完整性，提供元组的位置信息</td><td>用来和其他表建立联系用的</td></tr><tr><td>个数</td><td>一个表只能有一个</td><td>一个表可以有多个外键</td></tr></tbody></table><p>外键的优点：</p><ul><li>由数据库自身最大限度保证数据一致性，完整性</li><li>在一定程度上，说明了业务逻辑，设计更加全面。增加ER图可读性</li><li>联级操作方便。</li></ul><p>缺点：</p><ul><li>增加了复杂性，会平添开发难度，导致表更多等问题</li><li>维护工作复杂</li><li>降低耦合度，影响性能，对分库分表会造成影响。</li></ul><p>既然有外键，那么肯定有他存在的开发环境，当回答这种问题，不能一味的否定，现在项目越来越复杂，外键弊大于利，但是如果你的项目轻量，不分库分表，对性能没有要求，其实可以使用外键去简化一些过程的。</p><h3 id="_3-数据库三范式分别是什么" tabindex="-1"><a class="header-anchor" href="#_3-数据库三范式分别是什么" aria-hidden="true">#</a> 3.数据库三范式分别是什么？</h3><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖，换句话说非主属性对码完全函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h3 id="_4-mysql引擎支持哪些引擎-讲讲常用-myisam-和-innodb-的区别" tabindex="-1"><a class="header-anchor" href="#_4-mysql引擎支持哪些引擎-讲讲常用-myisam-和-innodb-的区别" aria-hidden="true">#</a> 4.Mysql引擎支持哪些引擎？讲讲常用 MyISAM 和 InnoDB 的区别</h3><figure><img src="https://cdn.jsdelivr.net/gh/baici1/image-host/image-20220304212100214.png" alt="image-20220304212100214" tabindex="0" loading="lazy"><figcaption>image-20220304212100214</figcaption></figure><p>支持的引擎如上。</p><p><code>MyISAM</code> 和 <code>InnoDB</code> 的区别从以下几个方面说明：</p><ol><li>是否支持行级锁</li></ol><p><code>MyISAM</code>：不提供行级锁，当处理并发时候，利用表锁。</p><p><code>InnoDB</code>：支持行级锁，权限细粒度更低，并发上比 <code>MyISAM</code> 更好。</p><ol start="2"><li>是否支持事务和外键</li></ol><p><code>MyISAM</code>：不支持事务。不支持外键</p><p><code>InnoDB</code>：支持事务和外键，具有提交(commit)和回滚(rollback)事务的能力。</p><ol start="3"><li>是否支持数据库异常崩溃后的安全恢复。</li></ol><p><code>MyISAM</code>：不支持</p><p><code>InnoDB</code>：支持，利用 <strong>redo log(重做日志)</strong> 将数据库状态恢复到你想要任意时刻。</p><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="_1-什么是索引-常用结构是什么" tabindex="-1"><a class="header-anchor" href="#_1-什么是索引-常用结构是什么" aria-hidden="true">#</a> 1.什么是索引？常用结构是什么？</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><h3 id="_2-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_2-索引的优缺点" aria-hidden="true">#</a> 2.索引的优缺点</h3><p>优点：</p><ul><li>大大加快数据的检索速度，这是主要原因</li><li>使用分组和排序语句，性能会有显著的提高。</li><li>唯一性索引，保证数据库中每一行数据的唯一性</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要时间，随着数据量变大，时间需要的更多。当表中数据发生更新时候，索引也需要动态维护。</li><li>创建索引占据空间，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li></ul><h3 id="_3-使用索引一定会提高查询速度-索引有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#_3-使用索引一定会提高查询速度-索引有哪些使用场景" aria-hidden="true">#</a> 3.使用索引一定会提高查询速度？索引有哪些使用场景？</h3><p>不一定！</p><p>场景很多，举常用的例子。</p><p>推荐使用索引场景：</p><ul><li>主键长度小，建立唯一索引</li><li>频繁用作查询条件的字段建立索引</li><li>需要排序或分组的字段建立索引</li><li>多个字段需要被查询建立复合索引</li></ul><p>不推荐建立索引场景：</p><ul><li>表的记录少，这时候全表扫描和索引查询时间差不多的。</li><li>增删改操作多，查询少的表不建议建立索引，当你进行增删改时候，需要时间去维护索引。</li><li>数据重复且分布平均的表字段，此时建立索引没有太大的实际效果。</li></ul><h3 id="_4-索引的底层数据结构聊一聊" tabindex="-1"><a class="header-anchor" href="#_4-索引的底层数据结构聊一聊" aria-hidden="true">#</a> 4.索引的底层数据结构聊一聊</h3><p>索引常见的数据结构：B 树， B+树和 Hash。</p><h4 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h4><p>hash 索引基于哈希表实现，哈希表是 (k,v) 键对的集合，可以通过键值 (k) 快速取到对应的值 (v)。<strong>MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型</strong>。</p><p><strong>实现原理</strong>：对于每一行数据，存储引擎会对索引列根据哈希函数计算一个<strong>哈希值</strong>，哈希索引将所有的哈希值存储在索引中，同时保存指向每个数据行的指针。哈希函数会存在哈希冲突，解决方法：链地址法（如果有多个列的哈希值相同，索引会以链表方式存放多个记录指针）</p><figure><img src="https://img-blog.csdnimg.cn/20210513092224836.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>使用限制：</p><ul><li>哈希索引数据不是按照索引值顺序存储，不能用于排序。</li><li>哈希索引不支持部分索引查找，必须使用所有的索引列来查找。</li><li>哈希索引只支持等值查询（=,IN(),&lt;,=,&lt;），不支持范围查询。</li><li>哈希冲突会影响查询速度。</li></ul><p>**总结：**哈希索引限制多，只适用于一定的场合（等值查询）。而一旦适合哈希索引，它带来的性能提升将非常显著。</p><h4 id="b树-b-树" tabindex="-1"><a class="header-anchor" href="#b树-b-树" aria-hidden="true">#</a> B树&amp;B+树</h4><p>推荐阅读：</p>',54),b={href:"https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190965&idx=1&sn=53f78fa037386f85531832cd5322d2a0&chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},m={href:"https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ?",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.codedump.info/post/20200609-btree-1/",target:"_blank",rel:"noopener noreferrer"},f=i(`<p>在一堆数据中查询一个数据时候，常用的数据结构二叉查找树（<code>binary search tree</code>，简称BST）、哈希桶等。以<code>BST</code> 为例，常见的实现有 <code>AVT</code>、红黑树等，由于这类型的树是平衡的，每次比较操作都会去掉当前数据量一半的数据，因此查找的时间复杂度为<code>O(logn)</code>。</p><figure><img src="https://www.codedump.info/media/imgs/20200609-btree-1/bst-example.png" alt="bst-example" tabindex="0" loading="lazy"><figcaption>bst-example</figcaption></figure><p>其实B树性能很不错，但是由于每个节点只能存储一个数据，可能导致树的高度会变高，每次查询的次数最坏情况会等于索引树的高度，逻辑上挨着的节点数据会离得很远（例如上面的34，35），这些问题好像不是很严重，毕竟B树是多路平衡树，可是设置合适的阶，其实这是分情况的。</p><p>在内存中操作数据，问题不大。</p><p>在磁盘中操作数据，会有一些不同点：</p><ul><li>读写磁盘数据很慢。</li><li>读写磁盘的最小单位是数据页。</li></ul><p>为了<strong>减少读写磁盘IO的次数，能够充分利用局部性原理，磁盘预读</strong>，需要把瘦高的B树结构变成矮胖的B+树。这种数据结构特点：<strong>每个节点能容纳更多的数据，这样就能降低树的高度，同时让逻辑上相邻的数据都能尽量的存储在物理上也相邻的硬盘空间上，减少磁盘读写。</strong></p><figure><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>当你使用主键索引时候，B+树非叶子节点存主键的值，叶子节点存整行数据。非主键索引，B+树非叶子节点存储非主键字段，叶子节点存储对应的主键值。</strong></p><p>在这里，一个节点越“胖”，意味着扇出（fanout）越大，同时高度越低，这两个性质决定了：</p><ul><li>高扇出：邻近键值的数据局部性更好。</li><li>低高度：遍历期间的寻道次数更少。</li></ul><h3 id="_5-为什么选择-b-作为mysql的索引-红黑树等平均树不行吗" tabindex="-1"><a class="header-anchor" href="#_5-为什么选择-b-作为mysql的索引-红黑树等平均树不行吗" aria-hidden="true">#</a> 5.为什么选择 B+ 作为Mysql的索引，红黑树等平均树不行吗？</h3><ul><li>更少的查找次数</li></ul><p>平衡树查找时间复杂度最坏的情况是<strong>等于树高 h</strong>。 B+ 树的出度大，高度低，矮胖矮胖的，红黑树出度为2，树高会比较大，时间复杂度就会高。</p><ul><li>利用磁盘的预读特性与局部性原理</li></ul><p><strong>局部性原理是指无论程序指令还是数据都趋于聚集在一个较小的连续区域中。</strong></p><p>为了尽量减少I/O操作，计算机系统一般采取<strong>预读的方式</strong>，预读的长度一般为<strong>页（page）的整倍数。</strong></p><p><strong>数据库系统将索引的一个节点的大小设置为页的大小，使得每一次 I/O 都能完全载入节点并且利用预读属性，相邻节点也能被预先载入，根据局部性原理，减少了 I/O 操作，比其他平衡树更加合适。</strong></p><h3 id="_6-聊一聊索引类型-你是怎么理解的" tabindex="-1"><a class="header-anchor" href="#_6-聊一聊索引类型-你是怎么理解的" aria-hidden="true">#</a> 6.聊一聊索引类型，你是怎么理解的？</h3><h4 id="主键索引" tabindex="-1"><a class="header-anchor" href="#主键索引" aria-hidden="true">#</a> 主键索引</h4><p>主键索引又被称作聚簇索引。</p><p>对于 <code>InnoDB</code> ，<code>rowid</code> 是每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的 <code>InnoDB</code> 来说 <code>rowid</code>就是主键 ID。</li><li>如果没有创建主键，系统会生成长度为 6 字节 <code>rowid</code> 来作为主键。</li><li>对于 <code>MEMORY</code> 引擎的 <code>rowid</code> 是数组下标。</li></ul><p>每张表都会有主键索引。</p><p><strong>主键索引的叶子节点存储的是整行的数据。</strong></p><h4 id="二级索引-辅助索引" tabindex="-1"><a class="header-anchor" href="#二级索引-辅助索引" aria-hidden="true">#</a> 二级索引(辅助索引)</h4><p>唯一索引，普通索引，前缀索引等都是属于二级索引，<strong>二级索引的叶子节点存储的数据是主键。</strong></p><ul><li>唯一索引：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li>普通索引：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li>前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符，<strong>会影响覆盖索引的使用。</strong></li><li><strong>全文索引</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul><h3 id="_7-你知道哪些索引的原则" tabindex="-1"><a class="header-anchor" href="#_7-你知道哪些索引的原则" aria-hidden="true">#</a> 7.你知道哪些索引的原则？</h3><h4 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h4><p>🌰：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#k是字段也是普通索引 T是表
select * from T where k between 3 and 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个查询语句工程中，<strong>k 索引树下查询 k=3 对应的 ID 值然后回到主键索引树中搜索所有的数据，这个过程我们称之为回表。</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>select ID from T where k between 3 and 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们需要查询的 ID 值在 k 索引树中的结果，可以直接返回查询结果，不用回表，这个过程我们称之为<strong>覆盖索引</strong>。在这个查询里面，对于索引树 k 已经<strong>覆盖</strong>了我们的查询需求。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则" tabindex="-1"><a class="header-anchor" href="#最左前缀原则" aria-hidden="true">#</a> 最左前缀原则</h4><p><strong>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p>🌰：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#现在有一个存储了id，姓名和年龄的表,姓名是索引。
select * from t where name like ‘张 %’
# 姓名，年龄是联合索引
select * from t where name like ‘张 %’
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个查询语句都可以使用索引。</p><p><strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</strong></p><h4 id="索引下推" tabindex="-1"><a class="header-anchor" href="#索引下推" aria-hidden="true">#</a> 索引下推</h4><p>索引下推：<strong>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</strong></p><p>mysql 会一直向右匹配索引，直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引。即：索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><p>🌰：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#现在有一个存储了id，姓名和年龄和性别的表,# 姓名，年龄是联合索引
select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>索引树会先查询姓张的数据，由于是 like 后面就不能用索引，通过索引下推然后再内部进行对age的判断，最后回表查询进行比较。</p><h3 id="_8-对一个字段-你会唯一索引还是普通索引" tabindex="-1"><a class="header-anchor" href="#_8-对一个字段-你会唯一索引还是普通索引" aria-hidden="true">#</a> 8.对一个字段，你会唯一索引还是普通索引？</h3><ul><li>业务要求优先：如果数据库的数据需要保证数据的唯一性，做约束，那么优先选择唯一索引。</li><li>如果业务没有要求，分场景去选择： <ul><li>写多读少的场景（账单，日志）推荐选择普通索引</li><li>写多读多的场景不推荐选择普通索引。</li></ul></li></ul><p>解释（主要解释第二条）：</p><blockquote><p>唯一索引和普通索引在查询上面性能上是差不多的。</p><p>在更新方面，两者有一定的差别：</p><ul><li>唯一索引：需要每次更新时候将磁盘中的数据读入内存，在进行更新操作。</li><li>普通索引：当需要更新的数据在内存中就直接更新，如果不在，更新记录写入 <strong>change buffer</strong>，后面在进行 <code>merge</code>，<strong>减少了将数据从磁盘读入内存的操作。</strong></li></ul><p><strong>change buffer</strong> 发起 <strong>merge</strong> 的条件：</p><ul><li>再次访问记录的数据页</li><li>定期merge</li><li>数据正常关闭时候。</li></ul></blockquote><h3 id="_9-哪些情况下-字段上有索引树-但是mysql却没有使用" tabindex="-1"><a class="header-anchor" href="#_9-哪些情况下-字段上有索引树-但是mysql却没有使用" aria-hidden="true">#</a> 9.哪些情况下，字段上有索引树，但是Mysql却没有使用？</h3><p><strong>只要对索引字段使用函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>举以下例子（都是用了函数操作）：</p><ul><li>对索引字段，<strong>使用常见的内置函数</strong>：<code>mounth().</code></li><li>对索引字段，<strong>隐式类型转换</strong>：字符串和数字比较，会将字符串转换成数字。</li><li>对索引字段，<strong>隐式字符编码转换</strong>：<code>utf8</code> 向 <code>utf8mb4</code> 转换。</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h3 id="_1-事务有哪些特性" tabindex="-1"><a class="header-anchor" href="#_1-事务有哪些特性" aria-hidden="true">#</a> 1. 事务有哪些特性？</h3><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="_2-并发事务会带来哪些问题" tabindex="-1"><a class="header-anchor" href="#_2-并发事务会带来哪些问题" aria-hidden="true">#</a> 2.并发事务会带来哪些问题？</h3><ul><li><strong>脏读</strong></li></ul><p>当一个事务 A 正在访问数据 D，并对其进行了修改，在事务提交之前有另一个事务 B 访问了并使用了修改后的数据 D，读到的数是<strong>脏数据</strong>，后续的操作都是无效的。</p><ul><li><strong>不可重复读</strong></li></ul><p>事务 A 访问了数据 B，这时候，事务 C 也访问了数据 B 并对其进行更新操作之后，事务 A 再次访问数据 B，发现前后读取的数据不一致。</p><ul><li><strong>幻读</strong></li></ul><p>事务 A 访问表里面一些数据，这时候，事务 B 往这个表里面插入了几条数据之后，事务 A 再次访问表里数据，发现多了一些原本不存在或者少了一些数据。</p><blockquote><p>注：</p><p>不可重复度和幻读，都是一个事务中对数据进行了多次的读取，前后数据不一致，但是着重点不一样。</p><p><strong>不可重复读的重点是数据的更新，幻读的重点是数据的新增和删除。</strong></p></blockquote><h3 id="_3-并发带来的问题怎么解决" tabindex="-1"><a class="header-anchor" href="#_3-并发带来的问题怎么解决" aria-hidden="true">#</a> 3.并发带来的问题怎么解决？</h3><p>可以通过 SQL 标准定义的隔离级别来解决：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更。<strong>无法解决问题。</strong></li><li><strong>READ-COMMITTED(读取已提交)</strong>：允许读取已经事务提交的数据。<strong>可以解决脏读。</strong></li><li><strong>REPEATABLE-READ(可重复读)</strong>：在事务开始到结束这一段过程，读取数据保持一致。<strong>可以阻止脏读和不可重复读</strong>。</li><li><strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。<strong>都可以解决。</strong></li></ul><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻影读</th></tr></thead><tbody><tr><td style="text-align:center;">READ-UNCOMMITTED</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">READ-COMMITTED</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">REPEATABLE-READ</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><h3 id="_4-在可重复读级别是怎么解决幻读" tabindex="-1"><a class="header-anchor" href="#_4-在可重复读级别是怎么解决幻读" aria-hidden="true">#</a> 4.在可重复读级别是怎么解决幻读？</h3><p><strong>间隙锁和行锁</strong>合称 <code>next-key lock</code>，<code>next-key lock</code>帮助解决幻读问题。但是注意：<strong>间隙锁的引入，可能会导致同样的语句锁住的范围更大，会影响到并发度的。</strong></p><blockquote><p>注：间隙锁只有在可重复读隔离级别才会生效。</p></blockquote><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><h3 id="_1-什么是乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_1-什么是乐观锁和悲观锁" aria-hidden="true">#</a> 1.什么是乐观锁和悲观锁</h3><p><strong>乐观锁</strong>：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于<strong>读多写少</strong>的场景。</p><p><strong>悲观锁</strong>：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于<strong>数据更新比较频繁</strong>的场景；</p><h3 id="_2-常见的封锁类型有哪些" tabindex="-1"><a class="header-anchor" href="#_2-常见的封锁类型有哪些" aria-hidden="true">#</a> 2.常见的封锁类型有哪些？</h3><ul><li><p><strong>排他锁（Exclusive Lock）/ X锁</strong>：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；</p></li><li><p><strong>共享锁</strong>（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。</p></li><li><p>意向锁</p><p>（Intention Locks）：</p><ul><li>一个事务在获得某个<strong>数据行</strong>对象的 S 锁之前，必须先获得<strong>整个表</strong>的 IS 锁（意向共享锁）或更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁（意向排他锁）；</li><li>IS/IX 锁之间都是兼容的；</li><li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了</li></ul></li></ul><h2 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h2><p>我们今天聊一聊关于日志方面的。</p><h3 id="_1-redo-log是什么-在mysql起着什么作用-记录了啥" tabindex="-1"><a class="header-anchor" href="#_1-redo-log是什么-在mysql起着什么作用-记录了啥" aria-hidden="true">#</a> 1.redo log是什么？在Mysql起着什么作用，记录了啥？</h3><p><code>redo log</code> （重做日志）是 <code>InnoDB</code> 引擎独有的，可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，保证了数据持久性与完整性，这个能力成为 <code>crash-safe</code>。</p><p>当有数据需要更新时候，会将磁盘需要更新数据的数据页加载进入内存中，在内存中进行更新数据，接下来就会把 ”<strong>在某个数据页上做了什么修改</strong>“ 这一条记录到 <code>redo log</code>，根据策略选择合适的时机，将记录写入磁盘中。</p><blockquote><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p></blockquote><h3 id="_2-redo-log日志是怎样工作的" tabindex="-1"><a class="header-anchor" href="#_2-redo-log日志是怎样工作的" aria-hidden="true">#</a> 2.redo log日志是怎样工作的？</h3><p><code>InnoDB</code> 的 <code>redo log</code> 是固定大小的，你可以选择进行配置。比如比如可以配置为一组 4 个文件，每个文件的大小是 <code>1GB</code>，那么 <code>redo log</code> 可以记录 <code>4G</code> 的内容。</p><p><code>redo log</code> 从头开始写，写到结尾，又回到开头循环写，如同一个圆，如下图：</p><figure><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>redo log</code> 有两个比较重要的属性：</p><ul><li><code>write pos</code> 是当前记录的位置，一边写一边后移。</li><li><code>checkpoint</code> 是当前要擦除的位置，也是向后推移。</li></ul><p><code>write pos</code> 和 <code>checkpoint</code> 之间的区域是可以用来记录新的操作。</p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示日志满了，那么不能写入新的更新记录了，需要停下来写入一些数据进入磁盘中，<code>checkpoint</code> 需要向后面移动。</p><h4 id="_4-redo-log每次都是什么时候将记录写入磁盘-总不能每次都写满了再去写入把" tabindex="-1"><a class="header-anchor" href="#_4-redo-log每次都是什么时候将记录写入磁盘-总不能每次都写满了再去写入把" aria-hidden="true">#</a> 4.redo log每次都是什么时候将记录写入磁盘，总不能每次都写满了再去写入把？</h4><p>与 <code>redo log</code> 刷盘相关的参数是 <code>innodb_flush_log_at_trx_commit</code>，具有三种值：</p><ul><li>0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>1：每次事务提交时MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认</li><li>2：每次事务提交时MySQL都会把日志缓存区的数据写入日志文件中，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。</li></ul><blockquote><p>分别说明每个模式的优缺点：</p><ul><li>当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失；</li><li>当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；</li><li>当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；</li></ul></blockquote><h3 id="_5-binlog-又是什么-他在mysql起着什么作用-记录了啥" tabindex="-1"><a class="header-anchor" href="#_5-binlog-又是什么-他在mysql起着什么作用-记录了啥" aria-hidden="true">#</a> 5.binlog 又是什么，他在Mysql起着什么作用，记录了啥？</h3><p><code>binlog</code> （归档日志）是在 <code>Server</code> 层的，主要做的是 <code>Mysql</code> 功能层面的事情，记录内容是语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p><p>不管你用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。<code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><h3 id="_6-既然谈到了-binlog-你能说一说redo-log和binlog-之间的一些异同点" tabindex="-1"><a class="header-anchor" href="#_6-既然谈到了-binlog-你能说一说redo-log和binlog-之间的一些异同点" aria-hidden="true">#</a> 6.既然谈到了 binlog 你能说一说redo log和binlog 之间的一些异同点？</h3><p>redo log 和 binlog 主要有三点不同：</p><ul><li>层面上来说： <ul><li><code>redo log</code> 是 <code>InnoDB</code> <strong>引擎特有</strong>的；</li><li><code>binlog</code> 是 <code>MySQL</code> 的 <code>Server</code> 层实现的，所有引擎都会产生。</li></ul></li><li>日志记录的数据来说： <ul><li><code>redo log</code> 是<strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；</li><li><code>binlog</code> 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li></ul></li><li>从写日志的方式来说： <ul><li><code>redo log</code> 是<strong>循环写的</strong>，空间固定会用完；</li><li><code>binlog</code> 是<strong>可以追加写入</strong>的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul></li><li>从能力来讲 <ul><li><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</li><li><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</li></ul></li></ul><h3 id="_7-binlog-又是什么时候将记录写入磁盘呢" tabindex="-1"><a class="header-anchor" href="#_7-binlog-又是什么时候将记录写入磁盘呢" aria-hidden="true">#</a> 7.binlog 又是什么时候将记录写入磁盘呢？</h3><p>与 binlog 刷盘的时机与参数 <code>sync_binlog</code> 相关。允许值：0～4,294,967,295。</p><ul><li>0：当事务提交时候，会把日志写入文件系统的 <code>page cache</code>，但是不会立即将数据写入磁盘中，而是系统自行判断什么时候写。</li><li>n：累计到 <code>n</code> 个事务时候，将文件系统的 <code>page cache</code> 的数据写入磁盘中。</li></ul><h3 id="_8-说到这了-这两个配置参数怎么样配置会更好" tabindex="-1"><a class="header-anchor" href="#_8-说到这了-这两个配置参数怎么样配置会更好" aria-hidden="true">#</a> 8.说到这了，这两个配置参数怎么样配置会更好</h3>`,109),y={href:"https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html",target:"_blank",rel:"noopener noreferrer"},x=i(`<p>推荐：参数都设置为1。</p><h3 id="_9-请完整详细一条更新语句-执行器和-innodb-引擎的运行过程" tabindex="-1"><a class="header-anchor" href="#_9-请完整详细一条更新语句-执行器和-innodb-引擎的运行过程" aria-hidden="true">#</a> 9.请完整详细一条更新语句，执行器和 InnoDB 引擎的运行过程？</h3><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>update T set c=c+1 where ID=2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>执行器操作引擎 <code>ID=2</code> 行数据，由于 <code>ID</code> 是主键，通过索引树可以直接找到。如果在内存中，直接返回执行器，如果内存没有，数据页从磁盘读入内存中。</li><li>执行器拿到数据后，进行更新数据，再次调用引擎接口写入这行数据。</li><li>引擎在将数据更新入内存中，同时将更新操作记录写入 <code>redo log</code>。</li><li>此时 <code>redo log</code> 处于 <code>prepare</code> 状态，然后告知执行器执行完成，可以提交事务。</li><li>执行器生成操作的 <code>binlog</code> 并写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 <code>redo log</code> 改成提交（<code>commit</code>）状态，更新完成。</li></ul><p><strong>（注重：关于内存的流程）</strong></p><figure><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_10-为什么redo-log在更新语句过程中会有两种状态呢" tabindex="-1"><a class="header-anchor" href="#_10-为什么redo-log在更新语句过程中会有两种状态呢" aria-hidden="true">#</a> 10.为什么redo log在更新语句过程中会有两种状态呢？</h3><p>第一种解答：</p><p>先用反证法去进行证明（例子依旧是上面的更新语句）：</p><ul><li><strong>先写 <code>redo log</code> 后写 <code>binlog</code>。</strong></li></ul><p>现在举例一个场景：<code>redo log</code> 写完了，<code>binlog</code> 还没有开始，这个时候如果 <code>Mysql</code> 进程异常重启。系统崩溃了，也能够把数据恢复起来，此时 <code>c=1</code>（c 的初值为 0）。但是 <code>binlog</code> 由于没有写入这一条记录，<strong>两个日志的状态逻辑上不一致</strong>。如果你后面用 <code>binlog</code> 去恢复数据，由于语句的丢失，恢复的数据为 <code>c=0</code>，与原库值不一致。</p><ul><li><strong>先写 <code>binlog</code> 后写 <code>redo log</code>。</strong></li></ul><p>举例：<code>binlog</code> 写完了，<code>redo log</code> 还没有写完，这个时候系统崩溃了，后面恢复的数据由于 <code>redo log</code> 没有写，导致 c=0，但是此时 binlog 已经记录了这一条操作了，<strong>两个日志的状态逻辑上不一致</strong>。后面用 <code>binlog</code> 恢复数据时候，恢复数据 <code>c=1</code> 与原库值不一致。</p><p>将 <code>redo log</code> 的写入拆成了两个步骤：<code>prepare</code> 和 <code>commit</code>，称之为&quot;<strong>两阶段提交</strong>&quot;。</p><p><strong>如果没有两阶段的提交，就会导致两个日志状态逻辑上不一致。</strong></p><p>第二种解答：</p><p>redo log 进行两阶段提交：当数据发生了崩溃的时候，恢复数据会对 redo log 进行一次判断：</p><ul><li>如果 redo log 已经是 commit 状态，代表这个过程没有发生意外，日志记录都已经写入了。</li><li>如果 redo log 处于 prepare 状态，需要通过 binlog 来判断此记录是否有效 <ul><li>如果 binlog 没有记录，那么此记录无效，无效就会回滚事务。</li><li>如果 binlog 记录成功了，那么此记录有效。</li></ul></li></ul><p><strong>两阶段的提交，保证了两个日志状态逻辑上是一致的。</strong></p><h2 id="综合" tabindex="-1"><a class="header-anchor" href="#综合" aria-hidden="true">#</a> 综合</h2><h3 id="_1-mysql有哪些部分组成" tabindex="-1"><a class="header-anchor" href="#_1-mysql有哪些部分组成" aria-hidden="true">#</a> 1.mysql有哪些部分组成？</h3><p>MySQL 主要分为 <code>Server</code> 层和存储引擎层：</p><p>Server 层：涵盖了 MySQL 的大多数核心服务功能以及所有的内置函数，所有跨存储引擎工程都在这一层实现，比如存储过程，触发器，视图等。</p><ul><li><strong>连接器</strong>：负责跟客户端建立连接、获取权限、维持和管理连接。</li><li><strong>查询缓存</strong>： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器</strong>：进行词法分析：分析 <code>SQL</code> 语句有哪些部分，进行语法分析：分析 <code>SQL</code> 语句是否满足 SQL 语法。</li><li><strong>优化器</strong>： 按照 MySQL 认为最优的方案去执行，例如怎么去选择索引。</li><li><strong>执行器</strong>：执行前会判断用户是否有执行查询的权限，根据表的引擎定义，去使用引擎提供的接口，返回结果。</li></ul><p>存储引擎层：负责数据的存储和提取，架构模式是插件式，支持 InnoDB，MyISAM，Memory 等多个引擎存储。</p><h3 id="_2-当收到you-have-an-error-in-your-sql-syntax-和-unknown-column-k-in-where-clause-分别会在哪一个部分报错" tabindex="-1"><a class="header-anchor" href="#_2-当收到you-have-an-error-in-your-sql-syntax-和-unknown-column-k-in-where-clause-分别会在哪一个部分报错" aria-hidden="true">#</a> 2.当收到You have an error in your SQL syntax 和 Unknown column ‘k’ in ‘where clause’，分别会在哪一个部分报错？</h3><p>分析器会做两件事情：</p><ul><li>解析阶段：会处理和解析语法，生成对应的解析树。</li><li>预处理阶段：进一步检测树的合法，比如数据表和数据列是否存在等。</li></ul><p>第一个报错会出现在<strong>分析器的解析阶段</strong>，第二个报错会出现在<strong>分析器的预处理阶段</strong>。</p>`,29);function q(k,v){const l=n("ExternalLinkIcon");return t(),a("div",null,[c,g,e("blockquote",null,[e("ul",null,[e("li",null,[e("a",h,[o("B树、B+树索引算法原理（上）"),d(l)])]),e("li",null,[e("a",p,[o("javaGuide"),d(l)])])])]),u,e("ul",null,[e("li",null,[e("a",b,[o("B树"),d(l)]),o("/"),e("a",m,[o("B+树"),d(l)])]),e("li",null,[e("a",_,[o("B树算法原理"),d(l)])])]),f,e("p",null,[o("参考文章："),e("a",y,[o("innodb_flush_log_at_trx_commit和sync_binlog参数详解"),d(l)])]),x])}const M=r(s,[["render",q],["__file","02.八股文进阶篇.html.vue"]]);export{M as default};
