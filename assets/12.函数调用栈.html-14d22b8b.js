const e=JSON.parse('{"key":"v-ea63c058","path":"/language/Go/12.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html","title":"函数调用栈","lang":"en-US","frontmatter":{"title":"函数调用栈","date":"2022-07-01T20:53:31.000Z","category":["语言基础","go"],"author":{"name":"团子","url":"https://github.com/baici1"},"comment":false,"description":"函数调用栈 我们按照编程语言的语法定义的函数，会被编译器编译为一堆堆机器指令，写入可执行文件。程序执行时可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段。 如果在一个函数中调用另一个函数，编译器就会对应生成一条call指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后跳回到调用处，继续执行。（如果学过微机原理，你可以懂得指令的含义） 函数栈帧 函数执行时候，需要有足够的内存空间，供他存放局部变量，参数等数据，这段空间对应到虚拟地址空间的栈。","icon":null,"isOriginal":true,"star":false,"article":true,"timeline":true,"image":null,"banner":null,"head":[["meta",{"property":"og:url","content":"https://yay-docs.yangdiy.cn/language/Go/12.%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.html"}],["meta",{"property":"og:site_name","content":"yay-docs"}],["meta",{"property":"og:title","content":"函数调用栈"}],["meta",{"property":"og:description","content":"函数调用栈 我们按照编程语言的语法定义的函数，会被编译器编译为一堆堆机器指令，写入可执行文件。程序执行时可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段。 如果在一个函数中调用另一个函数，编译器就会对应生成一条call指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后跳回到调用处，继续执行。（如果学过微机原理，你可以懂得指令的含义） 函数栈帧 函数执行时候，需要有足够的内存空间，供他存放局部变量，参数等数据，这段空间对应到虚拟地址空间的栈。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-05-31T15:06:12.000Z"}],["meta",{"property":"article:author","content":"团子"}],["meta",{"property":"article:published_time","content":"2022-07-01T20:53:31.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-31T15:06:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"函数调用栈\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-07-01T20:53:31.000Z\\",\\"dateModified\\":\\"2023-05-31T15:06:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"团子\\",\\"url\\":\\"https://github.com/baici1\\"}]}"]]},"headers":[{"level":2,"title":"函数栈帧","slug":"函数栈帧","link":"#函数栈帧","children":[]},{"level":2,"title":"传参","slug":"传参","link":"#传参","children":[]},{"level":2,"title":"返回值","slug":"返回值","link":"#返回值","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1685545572000,"updatedTime":1685545572000,"contributors":[{"name":"Y先生","email":"249337001@qq.com","commits":1}]},"readingTime":{"minutes":8.71,"words":2613},"filePathRelative":"language/Go/12.函数调用栈.md","localizedDate":"July 1, 2022","excerpt":"<h1> 函数调用栈</h1>\\n<p>我们按照编程语言的语法定义的函数，会被编译器编译为一堆堆机器指令，写入可执行文件。程序执行时可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段。</p>\\n<p>如果在一个函数中调用另一个函数，编译器就会对应生成一条<strong>call</strong>指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条<strong>ret</strong>指令，负责在函数结束后跳回到调用处，继续执行。（如果学过微机原理，你可以懂得指令的含义）</p>\\n<h2> 函数栈帧</h2>\\n<p>函数执行时候，需要有足够的内存空间，供他存放局部变量，参数等数据，这段空间对应到虚拟地址空间的栈。</p>","autoDesc":true}');export{e as data};
