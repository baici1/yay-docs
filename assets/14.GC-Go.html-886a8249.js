import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as n,c as i,a as e,b as o,f as s,d as l}from"./app-12e502b6.js";const r={},t=e("h1",{id:"gc-go语言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#gc-go语言","aria-hidden":"true"},"#"),o(" GC-Go语言")],-1),p=e("p",null,"推荐阅读：",-1),m={href:"https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&mid=2247484560&idx=2&sn=904e5b8cf262f1a127a9d9550776cc8d&chksm=c005d490f7725d86db7df38c3dcaa563b44b945ec26751efa477166a997ad153748c3c85ec73&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},u=l(`<p>Go语言垃圾回收采用标记–清扫算法，支持主体并发增量式回收，使用插入与删除两者写屏障结合的混合写屏障。</p><h2 id="基本情况" tabindex="-1"><a class="header-anchor" href="#基本情况" aria-hidden="true">#</a> 基本情况</h2><blockquote><p>三种 GC 模式</p></blockquote><p>Golang中垃圾回收支持三种模式：</p><ol><li><code>gcBackgroundMode</code>，默认模式，标记与清扫过程都是并发执行的；</li><li><code>gcForceMode</code>，只在清扫阶段支持并发；</li><li><code>gcForceBlockMode</code>，GC全程需要STW；</li></ol><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">const</span> <span class="token punctuation">(</span>
    gcBackgroundMode gcMode <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// concurrent GC and sweep</span>
    gcForceMode                    <span class="token comment">// stop-the-world GC now, concurrent sweep</span>
    gcForceBlockMode               <span class="token comment">// stop-the-world GC now and STW sweep (forced by user)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>两个全局变量</p></blockquote><p>关于 <code>GC</code> 执行过程，有两个重要的全局变量：<code>gcController</code> 和 <code>work</code>。</p><ol><li><code>gcController</code> 主要用于支持标记工作顺利执行</li></ol><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>
<span class="token keyword">var</span> gcController gcControllerState
<span class="token keyword">type</span> gcControllerState <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    scanWork <span class="token builtin">int64</span>
    bgScanCredit <span class="token builtin">int64</span>
    assistTime <span class="token builtin">int64</span>
    dedicatedMarkTime <span class="token builtin">int64</span>
    fractionalMarkTime <span class="token builtin">int64</span>
    idleMarkTime <span class="token builtin">int64</span>
    markStartTime <span class="token builtin">int64</span>

    dedicatedMarkWorkersNeeded <span class="token builtin">int64</span>
    fractionalUtilizationGoal <span class="token builtin">float64</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>gcController</code> 会记录一个 <code>mark cycle</code> (标记周期)中不同类型的 <code>mark worker</code> 是否还需要启动，是否需要进行 <code>assist mark</code>（辅助标记），已经执行了多少扫描工作，以及不同类型的 <code>mark worker</code> 分别执行了多长时间等信息。</p><ol start="2"><li><code>work</code> 用于存储全局工作信息</li></ol><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>
<span class="token keyword">var</span> work <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    full  lfstack          <span class="token comment">// lock-free list of full blocks workbuf</span>
    <span class="token operator">...</span><span class="token operator">...</span>
    bytesMarked <span class="token builtin">uint64</span>

    markrootNext <span class="token builtin">uint32</span> <span class="token comment">// next markroot job</span>
    markrootJobs <span class="token builtin">uint32</span> <span class="token comment">// number of markroot jobs</span>

    nFlushCacheRoots                               <span class="token builtin">int</span>
    nDataRoots<span class="token punctuation">,</span> nBSSRoots<span class="token punctuation">,</span> nSpanRoots<span class="token punctuation">,</span> nStackRoots <span class="token builtin">int</span>

    markDoneSema <span class="token builtin">uint32</span>

    bgMarkReady note   <span class="token comment">// signal background mark worker has started</span>
    bgMarkDone  <span class="token builtin">uint32</span> <span class="token comment">// cas to 1 when at a background mark completion point</span>
    mode gcMode
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>work</code> 提供全局工作队列缓存，并记录栈、数据段等需要扫描的 <code>root</code> 节点的相关信息；还会记录当前是第几个 <code>GC cycle</code>，当前 <code>GC cycle</code> 已经标记了多少字节，已经 <code>STW</code> 了多长时间，以及控制 <code>GC</code> 向下一阶段过度的信息等等。</p><h2 id="并发-gc-过程" tabindex="-1"><a class="header-anchor" href="#并发-gc-过程" aria-hidden="true">#</a> 并发 GC 过程</h2><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoedswHQTMxribGq5yNCQNGyqxI2UUwLdI5Ag9FxncDK8FMRsV0ibOClibaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>默认的 <code>gcBackgroundMode</code> （默认模式）下 <code>GC</code> 执行的大致过程如下：</p><ol><li><strong>Mark Setup</strong><ul><li>完成上一轮 <code>GC</code> 未完成的清扫工作</li><li>为每个 P 创建一个 <code>mark worker</code> 协程，陷入休眠，等待标记阶段得到调度（<code>findRunnableGCWorker</code>）</li></ul></li><li><strong>第一次 STW</strong><ul><li>开启写屏障</li><li>开启一个新一轮 GC，<code>gcphase</code> 置为 <code>_GCMark</code>，记录 <code>GC</code> 阶段标识；</li><li><code>writeBarrier.enabled</code> 置为 <code>true</code>，开启写屏障，<code>gcBlackenEnabled</code> 置为 1 表示允许 <code>GC</code> 进行标记工作。</li><li>在 <code>work</code> 中记录 <code>bss</code> 段，数据段，栈中那些 <code>root</code> 节点的必要信息，为 <code>root</code> 节点标记工作做准备。</li></ul></li><li><strong>Start The World，进入并发标记阶段。</strong><ul><li>后台 <code>mark worker</code> 得到调度执行时，会根据 <code>gcController</code> 中记录的相关信息决定 <code>worker</code> 的类型。</li><li>不管什么类型的 <code>worker</code> 都会先执行未完成的 <code>root</code> 标记工作，扫描协程栈时，只会暂停对应协程，通过 <code>stacmap</code> 标记扫描，结束后再将其恢复。</li><li><code>root</code> 标记工作完成后,需要继续追踪的 <code>root</code> 节点已经被记录到工作队列中，后台 <code>mark worker</code> 会继续处理工作队列中的节点，它们就是所谓的灰色节点。通过灰色节点可能发现更多灰色节点加入工作队列，处理完的灰色节点成为黑色节点。</li><li>当没有 <code>root</code> 标记任务与灰色节点时，<code>GC</code> 就可以进入 <strong>Mark Termination</strong> 阶段了。</li></ul></li><li><strong>第二次 STW</strong><ul><li><code>gcphase</code> 置为 <code>_GCMarkTermination</code></li><li>停止后台 <code>mark worker</code> 和 <code>assist worker</code></li><li><code>gcBlackenEnabled</code> 置为 0</li><li><code>gphase</code> 置为 <code>_GCOff</code></li><li>关闭写屏障，<code>writeBarrier.enabled</code> 置为 <code>false</code></li></ul></li><li><strong>Start The World，进入清扫阶段</strong><ul><li>进入 <code>_GCOff</code> 阶段以后，再新分配的对象就是白色的了。</li><li><code>runtime.main</code> 在程序初始化时会创建用于清扫的协程 <code>bgsweep</code>，存储在全局变量 <code>sweep</code> 中，到清扫阶段这个后台的 <code>sweeper</code> 会被加入到 <code>run queue</code> 中，它得到调度执行时会执行清扫任务。因为清扫工作也是增量进行的，每一轮 GC 开始之前，都要确保完成上一轮 GC 未完成的清扫工作。</li></ul></li></ol><h2 id="如何应对碎片化内存" tabindex="-1"><a class="header-anchor" href="#如何应对碎片化内存" aria-hidden="true">#</a> 如何应对碎片化内存</h2><p>我们知道 GC 应用的是<strong>标记-清扫算法</strong>的垃圾回收器，会存在一个问题，不可避免会造成内存碎片化。</p><ul><li>内存碎片化会增加内存分配的负担</li><li>降低内存使用率</li><li>要找到大小合适的内存块的代价会因碎片化而增加。</li></ul><p>解决这一问题的办法主要是使用<strong>多个链表</strong>，不同链表管理不同大小的内存块。</p><p>因为 <code>mutator</code> 通常不会频繁申请大块内存，所以多链表管理的内存块规格主要面向中小分块，既可以满足大部分内存分配需求，又避免维护大块空闲链表而压迫到内存。</p><p><code>Go</code> 语言的内存管理是基于 <code>TCMalloc</code> (Thread-Caching Malloc) 模型设计的，<code>TCMalloc</code> 是一种典型的分级、多链表内存管理模型，可以很好的应对碎片化内存。</p><blockquote><p><strong>Golang 内存管理大致结构</strong></p></blockquote><p>内存管理模块负责向操作系统申请内存并管理起来。</p><p><code>Golang</code> 的内存管理分为三级：</p><ul><li>mheap</li><li>mcentral</li><li>mcache</li></ul><p><code>mheap</code> 管理着虚拟地址空间中一大段连续的内存，我们之前说的堆分配，就是在这里分配。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoeXm9nSTUG5qNjtdoxCUx7BDqEXDTyOHCFica8Uj0XRPNiaSewc7UpV8dA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>多个 <code>page</code> 组成一个 <code>span</code> ，多个 <code>span</code> 组成一个 <code>arena</code>。</p><p><code>span</code> 对应的数据结构是 <code>mspan</code>，每个 <code>span</code> 都只存储一种大小的元素，类型规格记录在 <code>mspan.spanClass</code>中，类型规格覆盖了小于等于 32K 的 66 种大小，类型编号 1~66。大于 32K 的大对象直接在<code>mheap</code> 中分配，对应 <code>mspan</code> 的类型编号为 0，这样一共有 67 种。</p><p>同时 <code>spanClass</code> 还记录着该 <code>span</code> 存储元素是否含有指针，含有指针的属于 <code>scan</code> 类型，不含有指针的属于 <code>no-scan</code> 类型，所以总的来说 <code>span</code> 分类一共有 134 种。对于 <code>no-scan</code> 类型的 <code>mspan</code>，<code>GC</code> 并不关心。</p><p><code>mheap.central</code> 提供全局 <code>span</code> 缓存，它按照 <code>spanClass</code> 类型区分共 134 个 <code>mcentral</code>。每个 <code>mcentral</code> 管理一种 <code>spanclass</code> 的 <code>mspan</code>，并且会将有空闲空间和没有空闲空间的 <code>mspan</code> 分别管理。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L61XQqlgUVvtaOa97dMJSDORXAyjQ18482ticf0Cg7CgciadbdiaZqQEXpy1tzsMhbU9SkVkT19bU75A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>每个 <code>P</code> 都有一个 <code>mcache</code> 用作本地 <code>span</code> 缓存，与 <code>mcentral</code> 一样，每种规格类型对应 <code>scan</code> 和 <code>no-scan</code> 两个链表。小对象分配时先从本地 <code>mcache</code> 中获取，没有的话就去 <code>mcentral</code> 获取并设置到 <code>P</code>，<code>mcentral</code> 中也没有的话，会向 <code>mheap</code> 申请。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoea9coXmmy8DAR4ic6Pa7EW4tSOYTt20VicMMdQrd49ib2ZkicdgwTEorx0g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><blockquote><p>扫描和标记相关元数据</p></blockquote><ol><li><code>root</code> 节点扫描</li></ol><p><code>Go</code> 语言在编译阶段会生成 <code>bss</code> 段，数据段等对应的元数据，存储在可执行文件中，通过对应自己的 <code>modualdata</code>，根据其中存储的 <code>gcdatamask</code>、<code>gcbssmask</code> 等信息可以确定特定 <code>root</code> 节点是否需要添加到工作队列中。</p><p>协程栈的元数据存储在 <code>stackmap</code> 中，扫描协程栈时，通过对应元数据可以知道栈上的<strong>局部变量、参数、返回值</strong>等对象中哪些是存活的指针。</p><p>确定了 <code>root</code> 节点是否为指针，还要再进一步判断这些节点是否指向堆内存。</p><ol start="2"><li>堆扫描与标记</li></ol><p><code>mheap</code> 中每个 <code>arena</code> 对应一个 <code>HeapArena</code>，记录 <code>arena</code> 的<strong>元数据信息</strong>。</p><p>介绍一下<code>HeapArena</code> 中<code>bitmap</code> 和 <code>spans</code> 字段。</p><p><code>bitmap</code> 中一个 <code>byte</code> 可以标记 <code>arena</code> 中连续四个指针大小的内存。对于每一个 <code>word</code> 来说，对应了两个 <code>bit</code>，</p><ul><li>低位 <code>bit</code> 用于标记是否为指针，0 为非指针，1 为指针；</li><li>高位 <code>bit</code> 用于标记是否要继续扫描，高位 <code>bit</code> 为 1 就代表扫描完当前 <code>word</code> 并不能完成当前数据对象的扫描。</li></ul><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoeIY5pQgaIRlBC7icGubQk2O3hZYFQwmtHMucY0zWQVFKm7KicicrmtlbNQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><code>spans</code> 是一个 <code>*mspan</code> 类型的数组，用于记录当前 <code>arena</code> 中每一页对应到哪一个 <code>mspan</code>。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoeMBD3XOrWuOp41OCs4oXDW0xB6q7gZQXJV2JSfEtr9WHJc9HXSDGbeg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>所以，我们可以基于 <code>HeapArena</code> 记录的元数据信息，通过一个对象的地址，就可以根据 <code>HeapArena.bitmap</code> 信息扫描它内部是否含有指针，也可以根据对象地址计算出它在哪一页，进而查到存在哪一个 <code>mspan</code> 中</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoerEBNIk4ylMZ9dqsmOqboQ1bUm18Kem0Z9991aYcuHWEp2eLhZ7QPpg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>而每个 <code>span</code> 都对应两个位图标记：<code>mspan.allocBits</code> 和 <code>mspan.gcmarkBits</code>。</p><ul><li><code>allocBits</code> 中每一位用于标记一个对象存储单元是否已分配。</li><li><code>gcmarkBits</code> 中每一位用于标记一个对象是否存活。</li></ul><blockquote><p><strong>Golang中GC的三色标记</strong></p></blockquote><ul><li>灰色：<code>gcmarkBits</code> 置为 1 并加入工作队列中</li><li>黑色：<code>gcmarkBits</code> 置为 1</li><li>白色：<code>gcMarkBits</code> 置为 0</li></ul><h2 id="并发标志的分工问题与写屏障记录集竞争问题" tabindex="-1"><a class="header-anchor" href="#并发标志的分工问题与写屏障记录集竞争问题" aria-hidden="true">#</a> 并发标志的分工问题与写屏障记录集竞争问题</h2><p>每个 <code>P</code> 都有一个本地工作队列（<code>p.gcw</code>）和一个写屏障缓冲（<code>p.wbBuf</code>）。</p><p>本地工作队列（<code>p.gcw</code>）里面有两个 <code>workbuf</code>：分别是 <code>wbuf1</code> 和 <code>wbuf2</code>。工作过程如下：</p><ul><li>添加任务从 <code>wbuf1</code> 添加</li><li>当 <code>wbuf1</code> 满了时候，就会交换 <code>wbuf1</code> 和 <code>wbuf2</code> 。</li><li>如果交换之后还是满的，那么就会把当前的 <code>wbuf1</code> 的工作 <code>flush</code> 到全局工作缓存中。</li></ul><p><code>mark worker</code> 执行 <code>GC</code> 标记工作消耗工作队列时,会处理本地工作队列和全局工作缓存中工作量的均衡问题（<code>runtime.gcDrain</code>和<code>runtime.gcDrainN</code>中）</p><ul><li>如果全局工作缓存为空，就把当前的 <code>p</code> 的工作分一些到全局工作队列中。 <ul><li>如果 <code>wbuf2</code> 不为空，那么就将 <code>wbuf2</code> 整个 <code>flush</code> 到全局工作缓存中</li><li>如果 <code>wbuf2</code> 为空，那么考虑 <code>wbuf1</code>，如果 <code>wbuf1</code> 元素个数大于 4 ，就把 <code>wbuf1</code> 一半工作放到全局工作缓存中。</li></ul></li><li>如果本地工作队列为空，就会从全局工作缓存中获取任务放到本地队列中。</li></ul><p>当 <code>mutator</code> 触发写屏障时并不会直接操作工作队列，而是把相关指针写入当前 <code>p</code> 的写屏障缓冲区(<code>p.wbBuf</code>)中。当 <code>wbBuf</code> 已满或 <code>mark worker</code> 通过工作队列获取不到任务时,会把写屏障缓冲内容 <code>flush</code> 到工作缓存中,</p><p>通过这样<strong>区分本地工作队列与全局工作缓存，并为每个 P 设置了写屏障缓冲区</strong>，缓解了执行并发标记工作时操作工作队列的竞争问题。</p><h2 id="gc-对-cpu-的使用率" tabindex="-1"><a class="header-anchor" href="#gc-对-cpu-的使用率" aria-hidden="true">#</a> GC 对 CPU 的使用率</h2><p><code>GC</code> 默认的 <code>CPU</code> 的使用率为 25%。在 <code>GC</code> 执行的初始化阶段，会根据当前 <code>CPU</code> 核数 X 以 <code>CPU</code> 目标使用率来计算需要启动的 <code>mark worker</code> 数量。</p><p>但是会出现：<code>6*25%=1.5</code> 计算结果不为整数的情况，为了应对此情况，会对该结果进行 <code>rounding</code>（+0.5）。</p><p>但是这样的 <code>rounding</code> 会和目标使用率出现显著偏差（&gt;0.3），所以在 <code>mark worker</code> 中引入了不同的工作模式:</p><ul><li><strong><code>Dedicated</code></strong> 模式的 <code>worker</code> 会执行标记任务直到被抢占；</li><li><strong>Fractional</strong> 模式的 <code>worker</code> 除了被抢占外，还可以在达到目标使用率时主动让出。</li></ul><p>🌰：</p><p>如果有4个核，经过计算 <code>4*25%=1</code>，需要启动一个 <code>Dedicated</code> 模式的 <code>worker</code>。</p><p>如果有6个核，经过计算 <code>6*25%=1.5</code>，<code>rounding</code> 之后等于2，但是误差 <code>2/1.5-1=0.33</code>，大于0.3，所以启动一个 <code>Dedicated</code> 模式的 <code>worker</code> 和一个 <code>Fractional</code> 模式的 <code>worker</code> 来辅助完成额外的目标。</p><p>·调度器执行 <code>findRunnableGcWorker</code> 恢复 <code>mark worker</code> 时，需要设置 <code>worker</code> 运行的模式：</p><ul><li>如果 <code>Dedicated</code> 模式的 <code>worker</code> 数目没有达到上限，就设置为 <code>Dedicated</code> 模式。</li><li>接下来就要看是否需要 <code>Fractional</code> 模式的 <code>worker</code> 辅助工作，需要的话设置为 <code>Fractional</code> 模式</li></ul><p>P会记录自己执行 <code>Fractional</code> 模式的 <code>worker</code> 的时间，如果当前 <code>P</code> 执行 <code>Fractional</code> 模式的时间与本轮标记工作已经执行的时间的比率达到 <code>fractionalUtilizationGoal</code>，<code>Fractional</code> 模式的 <code>worker</code> 就可以主动让出了。</p><p>通过以上方式有效控制 <code>GC</code> 的 <code>CPU</code> 使用率。</p><h2 id="并发gc如何缓解内存分配压力" tabindex="-1"><a class="header-anchor" href="#并发gc如何缓解内存分配压力" aria-hidden="true">#</a> 并发GC如何缓解内存分配压力？</h2><p>为了避免 <code>GC</code> 执行过程中，内存分配压力过大，还实现了 <code>GC Assist</code> 机制，包括“辅助标记”和“辅助清扫”。</p><p>辅助标价：</p><p>如果协程在 <code>GC</code> 标记工作没有完成，想要分配内存，他就要负担一定的标记工作，申请的内存越大，对应负担的标记任务就越多，这是一种借贷偿还的机制。</p><p>当 <code>mark worker</code> 完成一定量的标记任务就会在全局 <code>gcController</code> 存一笔信用，有债务需要偿还，可以从<code>gcController</code>这里 <code>steal</code> 尽量多的信用来抵消自己欠下的债务。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4C74nN8hPUQ0bRKdzicldoeYQa1gicrhBS0tInnkXqNzeaTWc2bnSkS2gKQLIliaqw3eSJFZqyEwmEw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在清扫阶段内存分配可能会触发“辅助清扫”。</p><p>🌰：</p><ul><li>直接从 <code>mheap</code> 分配大对象时，为了维持内存分配量与清扫页面数的线性关系，可能需要执行一定量的清扫工作。</li><li>从本地缓存中直接分配一个 <code>span</code> 时，若存在尚未清扫的可用 <code>span</code>，也需要先清扫这个 <code>span</code> 再分配使用</li></ul>`,85);function b(g,k){const c=a("ExternalLinkIcon");return n(),i("div",null,[t,e("blockquote",null,[p,e("p",null,[e("a",m,[o("粗线条话GC（三）"),s(c)])])]),u])}const h=d(r,[["render",b],["__file","14.GC-Go.html.vue"]]);export{h as default};
