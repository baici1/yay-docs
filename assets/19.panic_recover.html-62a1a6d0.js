import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as p,a as n,b as a,f as t,d as i}from"./app-12e502b6.js";const d={},l=n("h1",{id:"panic-recover",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#panic-recover","aria-hidden":"true"},"#"),a(" panic & recover")],-1),u={href:"https://mp.weixin.qq.com/s/vcJ6TsnknaCoYhH6XZnNMw",target:"_blank",rel:"noopener noreferrer"},r=i(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>之前在 <code>defer</code> 的解析知道，当前执行的 <code>goroutine</code> 持有一个 <code>defer</code> 链表的头指针。其实他也有一个 <code>panic</code> 头指针。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRU6TwxQoNiaPRmJbdef2OfTLyiamP217QKkbUzaqju5yd4mJbT5WnlBRA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>接下来看看 <code>panic</code> 是怎么处理的。</p><h2 id="panic" tabindex="-1"><a class="header-anchor" href="#panic" aria-hidden="true">#</a> panic</h2><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA&quot;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;这里不会被执行&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A2正常结束&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A1正常结束&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数 <code>A</code> 注册了两个 <code>defer</code> 函数 <code>A1</code> 和 <code>A2</code>，然后发生了 <code>panic</code>。发生 <code>panic</code> 后，它会立刻停止执行当前函数剩余代码，而是进入了 <code>panic</code> 处理逻辑函数。</p><p>首先会在 <code>panic</code> 链表头处增加一项 <code>panicA</code>，是现在的执行的 <code>panicA</code>，然后在当前的 <code>goroutine</code> 递归执行注册的 <code>defer</code> 函数。这里有点不一样的地方。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">//defer 1.12</span>
<span class="token keyword">type</span> _defer <span class="token keyword">struct</span> <span class="token punctuation">{</span> 
    siz       <span class="token builtin">int32</span>
    started   <span class="token builtin">bool</span>    <span class="token comment">// panic执行defer时会把它标记为true</span>
    sp        <span class="token builtin">uintptr</span> 
    pc        <span class="token builtin">uintptr</span>
    fn        <span class="token operator">*</span>funcval
    _panic    <span class="token operator">*</span>_panic <span class="token comment">// 记录触发defer执行的_panic指针</span>
    link      <span class="token operator">*</span>_defer
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>panic</code> 执行到一个 <code>defer</code> 会先将他的 <code>_defer</code> 结构体的字段 <code>started</code> 设为 <code>true</code>，代表他已经开始执行了，并将字段 <code>_panic</code> 指向当前执行的 <code>panic</code>，表示当前执行的 <code>defer</code> 函数由这个 <code>panic</code> 函数触发的。</p><p>处理完字段赋值，函数 <code>A2</code> 就会正常执行与结束，然后就会移除这一项，继续执行下一个 <code>defer</code>。</p><p>之所以要等到 <code>defer</code> 函数正常返回以后再移除对应的 <code>defer</code> 链表项，主要是为了应对 <code>defer</code> 函数没有正常结束的情况。</p><h2 id="defer-非正常结束" tabindex="-1"><a class="header-anchor" href="#defer-非正常结束" aria-hidden="true">#</a> defer 非正常结束</h2><p>我们再来看个例子：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">defer</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA&quot;</span><span class="token punctuation">)</span><span class="token comment">//打印panic 信息</span>
<span class="token punctuation">}</span>   
<span class="token keyword">func</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A1再次panic&quot;</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA1&quot;</span><span class="token punctuation">)</span><span class="token comment">//打印panic信息</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在函数 A 中先注册 <code>defer</code> 函数 <code>A1</code>，然后执行到 <code>panic</code>，<code>panic</code> 链表就会增加一项 <code>panicA</code>。之后就会执行 <code>defer</code> 链表的函数。<code>A1</code> 的 <code>_defer</code> 结构体会将 <code>started</code> 置为 <code>true</code> 和 <code>_panic</code> 指向当前执行的 <code>panic</code>。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRtdPd2MX0V8aRqWoGic7dncC5icSCYcZq8SMB4tleRhNnI5dIdKvF9Tcw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>A1 开始执行，再次发生了 <code>panic</code>，当前函数立刻停止执行剩下的代码，在 <code>panic</code> 链表插入了一个新的 <code>_panic</code>，记为 <code>panicA1</code>。</p><p>现在要开始去执行 <code>defer</code> 链表的函数了，但是发现 <code>defer</code> 链表的函数 <code>A1</code>，触发执行的不是当前 <code>panicA1</code>，是之前的 <code>panicA</code>。</p><p>这里会根据 A1 的字段 <code>_panic</code> 找到之前触发执行的 <code>panicA</code> 函数，将它标记为终止。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> _panic <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    argp      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">//用来存储panic正在执行的defer函数的参数空间地址;</span>
    arg       <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//是panic函数自己的参数;</span>
    link      <span class="token operator">*</span>_panic <span class="token comment">//自然是链到上一个_panic结构体；</span>
    recovered <span class="token builtin">bool</span> <span class="token comment">//标识这个panic是否被恢复；</span>
    aborted   <span class="token builtin">bool</span> <span class="token comment">//标识这个panic是否被终止。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>panicA</code> 的结构体字段 <code>aborted</code> 置为 <code>true</code>。并移除 <code>defer</code> 链表的 <code>A1</code> 函数。</p><p>此时链表已经为空了，那么对于当前执行的 <code>panicA1</code> 函数，没有需要去递归执行的 <code>defer</code> 函数了，就要开始打印信息了。</p><p><code>panic</code> 打印信息<strong>从链表尾开始</strong>，也就是根据链表项插入顺序逐一输出。在这里就会先输出 <code>panicA</code> 的信息然后输出 <code>panicA1</code> 的信息，程序结束。</p><p>关键点：</p><ul><li><code>panic</code> 执行 <code>defer</code> 函数方式是：先标记，执行结束后移除，如果触发指针不匹配则终止之前工作的 <code>panic</code>。</li><li><code>panic</code> 打印异常信息：顺序从链表尾输出即根据注册顺序来输出信息，所有在 <code>panic</code> 链表的都会被输出。</li></ul><h2 id="recover" tabindex="-1"><a class="header-anchor" href="#recover" aria-hidden="true">#</a> recover</h2><p><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃，但是它只能在 <code>defer</code> 中发挥左右，在其他作用域中调用不会起作用。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA&quot;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;这里不会被执行&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">//这里会正常执行输出“panicA”</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A1正常结束&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加了 <code>recover</code> 好像就可以正常执行程序了，那么这个流程又会是怎么样的呢？</p><p>函数 <code>A</code> 会在当前执行的 <code>goroutine</code> 注册 <code>defer</code> 函数 <code>A1</code> 和 <code>A2</code>。然后在 <code>panic</code> 链表增加一项 <code>panicA</code>。接着就会递归执行 <code>defer</code> 链表的函数，先执行 <code>A2</code>。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRDWX7xAPQ7IHRxtcwFicueWdDibICLNicNO6ibMwFYerFtCCOmYjibOMCO7A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>当执行 <code>A2</code> 函数时候，会发生 <code>recover</code>，其实 <code>recover</code> 函数的做的事情很少，就是将当前执行的 <code>panic</code> 字段 <code>recovered</code> 置为 <code>true</code>。<code>A2</code> 函数接着继续执行，直到结束。</p><p>每次 <code>defer</code> 函数执行完后，在 <code>panic</code> 处理流程都会去检查当前执行的 <code>panic</code> 是否被恢复了，如果被恢复了，那么就会移除。</p><p><code>A2</code> 执行完后，发现当前执行的 <code>panic</code> 已经被恢复了，那么把它从 <code>panic</code> 链表中移除，同时 <code>A2</code> 执行完后，也会从 <code>defer</code> 函数移除。但是在 <code>A2</code> 移除前，会要保存 <code>_defer</code> 结构体的 <code>sp</code> 和 <code>pc</code> 两个字段的值。</p><p><strong>为什么要保存这两个字段啊？有什么用吗？当前的 panic 函数还没有结束哦！</strong></p><p>先说明这两个字段的作用：</p><ul><li><code>sp</code>：函数 <code>A</code> 的栈指针。</li><li><code>pc</code>：调用 <code>deferproc</code> 函数的返回地址。</li></ul><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRO7c2rZ7OLeVZ3yiaJLK1upl2w42abQpqbnWcyYBFIa7qqOXMur21XeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>根据这段伪指令，我们直到利用 <code>sp</code> 字段能够回到函数 <code>A</code> 的栈帧，利用 <code>pc</code> 字段可以通过返回地址的值 <code>r</code> 通过判断回到 <code>deferreturn</code> 这里然后继续执行 <code>defer</code> 链表的函数。</p><p><strong>注：函数 <code>A</code> 这里的 <code>deferreturn</code> 只负责执行函数 <code>A</code> 中注册的 <code>defer</code> 函数，也是通过 <code>sp</code> 字段去判断的。</strong></p><p>兜兜转转又回到了 <code>defer</code> 链表，下一个执行的函数是 <code>A1</code>，是函数 <code>A</code> 注册的。执行函数 <code>A1</code>，结束后 <code>defer</code> 链表为空，函数 <code>A</code> 结束了。</p><p>关键点：</p><ul><li><code>recover</code> 做的事情很少，就是将当前的 <code>panic</code> 结构体字段 <code>recovered</code> 置为 <code>true</code> ，代表此 <code>panic</code> 被恢复了。</li><li><code>panic</code> 恢复后，会被移除然后通过 <code>sp</code> 和 <code>pc</code> 字段通过判断恢复到 <code>defer</code> 链表，执行的函数都是同一个函数注册的 <code>defer</code> 函数</li><li>在发生 <code>recover</code> 的函数正常返回以后，才会检测当前 <code>panic</code> 是否被恢复，然后才会删除被恢复的 <code>panic</code>。</li></ul><h2 id="recoder-非正常结束" tabindex="-1"><a class="header-anchor" href="#recoder-非正常结束" aria-hidden="true">#</a> recoder 非正常结束</h2><p>如果 <code>recover</code> 不是正常返回结果，中间又有一个 <code>panic</code>，那么这过程又会发生什么呢？</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA&quot;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;这里不会被执行&quot;</span><span class="token punctuation">)</span><span class="token comment">//输出异常信息</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	p <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">//这里会正常执行输出“panicA”</span>
	<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;panicA2&quot;</span><span class="token punctuation">)</span> <span class="token comment">//输出异常信息</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A1正常结束&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之前的过程省略，直接来到关键处。</p><p>当 <code>panicA</code> 被恢复时候，<code>A2</code> 函数会继续接着执行（注：只有正常返回才会移除 <code>panicA</code>），再次发生了 <code>panic</code>，在 <code>panic</code> 链表增加了一项 <code>panicA2</code>。现在他是当前执行的 <code>panic</code> 函数了。</p><p>在执行 <code>panicA2</code> 流程会触发 <code>defer</code> 链表的执行，发现 <code>defer</code> 函数 <code>A2</code> 已经被执行了，触发者是之前的 <code>panicA</code>。那么就会终止 <code>panicA</code>，<code>A2</code> 也会从 <code>defer</code> 链表中移除。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRvk1lEWnXhWcda1uQDwm8hgGoA1lT6waLzR4SN0yeQFSU7NqicibYuJZw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>咦！好像 <code>panicA</code> 没有被移除，即使他现在被恢复了。它会被移除吗？接着往下看。</p><p><code>panicA2</code> 函数会继续去执行 <code>defer</code> 链表接下来的函数 <code>A1</code>。<code>A1</code> 的 <code>_defer</code>结构体中 <code>_panic</code> 会指向 <code>panicA2</code>。</p><p><code>A1</code> 结束了，那么就要开始输出异常信息了。</p><p>输出异常信息，会将 <code>panic</code> 链表的所有项都会输出出来，不同的是 <code>panicA</code> 会被打上 <code>recover</code> 标记。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>panic: panicA <span class="token punctuation">[</span>recovered<span class="token punctuation">]</span>
	panic: panicA2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="recover-限制" tabindex="-1"><a class="header-anchor" href="#recover-限制" aria-hidden="true">#</a> recover 限制</h2><p>recover 函数只能在 defer 函数中直接调用，也不能间接调用，如果不满足这个要求，那么 recover 不会有任何效果。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L6DI134xDP4GZnDlEvP9ibyRlYHtt9ZWnUSczRsmxMtR7uaA3aFn0LZEaCQUVIbyvLuYEMXuJL4GBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="后续" tabindex="-1"><a class="header-anchor" href="#后续" aria-hidden="true">#</a> 后续</h2><p>我们知道在 <code>1.14</code> 版本后 <code>defer</code> 的执行改成了 <code>open coded defer</code> 的方式，既然 <code>panic</code> 需要调用 <code>defer</code> 链表，所以那些没有注册到 <code>defer</code> 链表会通过栈扫描注册到 <code>defer</code> 链表中。剩余的过程是很繁琐的，都是为了迎合 <code>open coded defer</code>。但是 <code>panic</code> 和 <code>recover</code> 的总体设计思路不变。</p>`,61);function k(v,m){const s=c("ExternalLinkIcon");return o(),p("div",null,[l,n("blockquote",null,[n("p",null,[a("推荐阅读："),n("a",u,[a("【Golang】图解panic & recover"),t(s)])])]),r])}const g=e(d,[["render",k],["__file","19.panic_recover.html.vue"]]);export{g as default};
